<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Create Stylized GPU Instancing Billboard Grass Without Creating Position Buffer in URP | Yaotian Huang</title>
<meta name="keywords" content="Unity, Shader, GPU Instancing, Grass, URP">
<meta name="description" content="Environment Unity 2021.3.16f1
URP 12.0
Prerequisite Basic knowledge of C# and Shader programming (HLSL).
GPU Instancing GPU instancing is a technique that allows you to draw multiple copies of the same mesh using a single draw call. It is basically normal forward rendering pipeline but skipping the Vertex Specification stage.
Graphics.DrawMeshInstancedIndirect The first step to create multiple millions of grass is to properly call the GPU to draw so, a.k.a. draw call.">
<meta name="author" content="sky_haihai">
<link rel="canonical" href="https://sky-haihai.github.io/Yaotian-Huang/posts/gamedev/create-stylized-gpu-instancing-billboard-grass-without-creating-position-buffer-in-urp/">
<link crossorigin="anonymous" href="/Yaotian-Huang/assets/css/stylesheet.62aa25427797f8efd87301a5b69795dc50df2dbe79a5fba0648cc7bb8dbcd7c9.css" integrity="sha256-YqolQneX&#43;O/YcwGltpeV3FDfLb55pfugZIzHu42818k=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/Yaotian-Huang/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://sky-haihai.github.io/Yaotian-Huang/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sky-haihai.github.io/Yaotian-Huang/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sky-haihai.github.io/Yaotian-Huang/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sky-haihai.github.io/Yaotian-Huang/apple-touch-icon.png">
<link rel="mask-icon" href="https://sky-haihai.github.io/Yaotian-Huang/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://sky-haihai.github.io/Yaotian-Huang/posts/gamedev/create-stylized-gpu-instancing-billboard-grass-without-creating-position-buffer-in-urp/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Create Stylized GPU Instancing Billboard Grass Without Creating Position Buffer in URP" />
<meta property="og:description" content="Environment Unity 2021.3.16f1
URP 12.0
Prerequisite Basic knowledge of C# and Shader programming (HLSL).
GPU Instancing GPU instancing is a technique that allows you to draw multiple copies of the same mesh using a single draw call. It is basically normal forward rendering pipeline but skipping the Vertex Specification stage.
Graphics.DrawMeshInstancedIndirect The first step to create multiple millions of grass is to properly call the GPU to draw so, a.k.a. draw call." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sky-haihai.github.io/Yaotian-Huang/posts/gamedev/create-stylized-gpu-instancing-billboard-grass-without-creating-position-buffer-in-urp/" /><meta property="og:image" content="https://sky-haihai.github.io/Yaotian-Huang/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-04T11:59:37-07:00" />
<meta property="article:modified_time" content="2024-03-04T11:59:37-07:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://sky-haihai.github.io/Yaotian-Huang/papermod-cover.png"/>

<meta name="twitter:title" content="Create Stylized GPU Instancing Billboard Grass Without Creating Position Buffer in URP"/>
<meta name="twitter:description" content="Environment Unity 2021.3.16f1
URP 12.0
Prerequisite Basic knowledge of C# and Shader programming (HLSL).
GPU Instancing GPU instancing is a technique that allows you to draw multiple copies of the same mesh using a single draw call. It is basically normal forward rendering pipeline but skipping the Vertex Specification stage.
Graphics.DrawMeshInstancedIndirect The first step to create multiple millions of grass is to properly call the GPU to draw so, a.k.a. draw call."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sky-haihai.github.io/Yaotian-Huang/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Create Stylized GPU Instancing Billboard Grass Without Creating Position Buffer in URP",
      "item": "https://sky-haihai.github.io/Yaotian-Huang/posts/gamedev/create-stylized-gpu-instancing-billboard-grass-without-creating-position-buffer-in-urp/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Create Stylized GPU Instancing Billboard Grass Without Creating Position Buffer in URP",
  "name": "Create Stylized GPU Instancing Billboard Grass Without Creating Position Buffer in URP",
  "description": "Environment Unity 2021.3.16f1\nURP 12.0\nPrerequisite Basic knowledge of C# and Shader programming (HLSL).\nGPU Instancing GPU instancing is a technique that allows you to draw multiple copies of the same mesh using a single draw call. It is basically normal forward rendering pipeline but skipping the Vertex Specification stage.\nGraphics.DrawMeshInstancedIndirect The first step to create multiple millions of grass is to properly call the GPU to draw so, a.k.a. draw call.",
  "keywords": [
    "Unity", "Shader", "GPU Instancing", "Grass", "URP"
  ],
  "articleBody": "Environment Unity 2021.3.16f1\nURP 12.0\nPrerequisite Basic knowledge of C# and Shader programming (HLSL).\nGPU Instancing GPU instancing is a technique that allows you to draw multiple copies of the same mesh using a single draw call. It is basically normal forward rendering pipeline but skipping the Vertex Specification stage.\nGraphics.DrawMeshInstancedIndirect The first step to create multiple millions of grass is to properly call the GPU to draw so, a.k.a. draw call. In Unity, we can use Graphics.DrawMeshInstancedIndirect to create a GPU instancing draw call.\n// Graphics.cs public void DrawMeshInstancedIndirect( Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset = 0, MaterialPropertyBlock properties = null, ShadowCastingMode castShadows = ShadowCastingMode.On, bool receiveShadows = true, int layer = 0, Camera camera = null, LightProbeUsage lightProbeUsage = LightProbeUsage.BlendProbes, LightProbeProxyVolume lightProbeProxyVolume = null ); Most of the parameters are self-explanatory. The ComputeBuffer bufferWithArgs is the most important one. It is a buffer that contains the arguments for the draw call. This has to be exacly a 5 elements long int array.\nint[] args = new int[5] { 0, 0, 0, 0, 0 }; The five arguments that we are going to fill inside this int array are:\nthe number of instances the number of instances to draw the start instance location the base vertex location the start index location With the knowledge above, we can create a simple script to draw a single mesh with GPU instancing.\nusing UnityEngine; public class BillboardGrassRenderer : MonoBehaviour { public Mesh mesh; public int subMeshIndex = 0; public int instanceCount = 1000; public Vector3 dimension = new Vector3(10, 10, 10); public Vector2 density = new Vector2(10, 10); private Material m_Material; private MaterialPropertyBlock m_PropertyBlock = new MaterialPropertyBlock(); private ComputeBuffer m_ArgsBuffer; private uint[] m_Args = new uint[5] { 0, 0, 0, 0, 0 }; private void Start() { m_ArgsBuffer = new ComputeBuffer(1, m_Args.Length * sizeof(uint), ComputeBufferType.IndirectArguments); m_Args[0] = (uint)mesh.GetIndexCount(subMeshIndex); m_Args[1] = (uint)instanceCount; m_Args[2] = (uint)mesh.GetIndexStart(subMeshIndex); m_Args[3] = (uint)mesh.GetBaseVertex(subMeshIndex); m_Args[4] = 0; m_ArgsBuffer.SetData(m_Args); var dimensionAndDensity = new Vector4(dimension.x, dimension.z, density.x, density.y); m_PropertyBlock.SetVector(DimensionAndDensityPropertyID, dimensionAndDensity); m_Material = new Material(Shader.Find(\"Universal Render Pipeline/Lit\")); } private void Update() { Graphics.DrawMeshInstancedIndirect(mesh, subMeshIndex, m_Material, new Bounds(transform.position, dimension), m_ArgsBuffer, 0, m_PropertyBlock); } private void OnDisable() { if (m_ArgsBuffer != null) { m_ArgsBuffer.Release(); } _argsBuffer = null; } } Material As you probably noticed in the script, the grass material is currently using URP/Lit as its shader. As we didn’t compute the grass positions anywhere, the grass will be drawn at the origin. We can fix this in two ways:\nCompute position info in the shader Use a compute shader to calculate the positions, and a compute buffer to store the positions info and pass it to the shader. The difference between the two methods is that the first method is more efficient as there’s no need to pass the information around between CPU and GPU , but the second method is more flexible. We will use the first method in this tutorial.\nShader \"Hidden/XiheRendering/BillboardGrassUnlit\" { Properties { _MainTex (\"Albedo (RGB)\", 2D) = \"white\" {} } SubShader { Cull Off Zwrite On Pass { Name \"BillboardGrassForward\" Tags { \"LightMode\" = \"UniversalForward\" } HLSLPROGRAM #pragma vertex Vertex #pragma fragment Fragment #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\" TEXTURE2D(_MainTex); SAMPLER(sampler_MainTex); struct Attributes { float4 vertex : POSITION; float4 uv : TEXCOORD0; }; struct Varyings { float4 positionHCS : SV_POSITION; float2 uv : TEXCOORD0; }; Varyings Vertex(Attributes IN, uint instanceID : SV_InstanceID) { Varyings o; o.positionHCS = TransformObjectToHClip(IN.vertex.xyz); o.uv = IN.uv.xy; return o; } float4 Fragment(Varyings IN) : SV_Target { float4 albedo = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv); clip(albedo.a - 0.5); return albedo; } ENDHLSL } } } GPU Instancing Keywords and Macros First thing is first, in order to let the shader support GPU instancing, we need to add #pragma multi_compile_instancing to the shader. This will tell the shader to generate multiple shader variants for each instance.\nAll keywords and macros can be found here: Creating shaders that support GPU instancing.\nMaterial Property In this basic shader, we first declare the _Dimension property inside the UNITY_INSTANCING_BUFFER_START and UNITY_INSTANCING_BUFFER_END macros.\nUNITY_INSTANCING_BUFFER_START(Props) UNITY_DEFINE_INSTANCED_PROP(float4, _Dimension) //x: dimensionX, y: dimensionZ, z: densityX, w: densityZ UNITY_INSTANCING_BUFFER_END(Props) UNITY_INSTANCING_BUFFER is a per-instance type of CBUFFER which will receive values from MaterialPropertyBlock from C# side.\nWe will use this property to calculate a 2D(XZ) position offset(similar to DispatchThreadID) of the grass instance. Let’s first draw a grass instance every 1 meter on the x-axis and 1 meter on the z-axis. We can then calculate the offset distance for each instance on the x and z axis using the instance ID and the _Dimension property.\n_Dimension.x: dimension of the grass bounding volume on the x-axis _Dimension.y: dimension of the grass bounding volume on the z-axis _Dimension.z: density of the grass per meter on the x-axis _Dimension.w: density of the grass per meter on the z-axis //actual number of instances allowed on z-axis float dimensionZ = floor(_Dimension.y * _Dimension.w); float offsetX = floor(instanceID / dimensionZ) / _Dimension.z; float offsetZ = instanceID % dimensionZ / _Dimension.w; Local Position Offset Now we got offset distance for each instance on the x and z axis, add the offset to the origin position and subtract half of the bounding volume to get a local position from the left, backward corner of the bounding volume:\nfloat3 localPositionOffset = localPosition - float3(_Dimension.x, 0, _Dimension.y) / 2.0 + float3(offsetX, 0, offsetZ); Noise Texture UV We can also calculate the normalized offset to get a grass-bounding-box-space UV for sampling scrolling noise textures later, x-axis is the offsetX, y-axis is the offsetZ. We can use this UV to sample the noise texture later to add some wind effect to the grass.\n//normalized instance ID in 2D space float2 instanceID2D01 = float2(offsetX / _Dimension.x, offsetZ / _Dimension.y); Static GPU Instancing Grass Shader Putting all the pieces together, we get the following shader:\nShader \"Hidden/XiheRendering/BillboardGrassUnlit\" { Properties { _MainTex (\"Albedo (RGB)\", 2D) = \"white\" {} } SubShader { Cull Off Zwrite On Pass { Name \"BillboardGrassForward\" Tags { \"LightMode\" = \"UniversalForward\" } HLSLPROGRAM #pragma vertex Vertex #pragma fragment Fragment #pragma target 4.5 #pragma multi_compile_instancing #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\" UNITY_INSTANCING_BUFFER_START(Props) UNITY_DEFINE_INSTANCED_PROP(float4, _Dimension) //x: dimensionX, y: dimensionZ, z: densityX, w: densityZ UNITY_INSTANCING_BUFFER_END(Props) TEXTURE2D(_MainTex); SAMPLER(sampler_MainTex); struct Attributes { float4 vertex : POSITION; float4 uv : TEXCOORD0; }; struct Varyings { float4 positionHCS : SV_POSITION; float2 uv : TEXCOORD0; }; Varyings Vertex(Attributes IN, uint instanceID : SV_InstanceID) { float dimensionZ = floor(_Dimension.y * _Dimension.w); //actual number of instances allowed on z-axis float offsetX = floor(instanceID / dimensionZ) / _Dimension.z; float offsetZ = instanceID % dimensionZ / _Dimension.w; float3 localPosition = IN.vertex.xyz; float2 instanceID2D01 = float2(offsetX / _Dimension.x, offsetZ / _Dimension.y);//no use for now, use this to sample noise later float3 localPositionOffset = localPosition - float3(_Dimension.x, 0, _Dimension.y) / 2.0 + float3(offsetX, 0, offsetZ); Varyings o; o.positionHCS = TransformObjectToHClip(localPositionOffset); o.uv = IN.uv.xy; return o; } float4 Fragment(Varyings IN) : SV_Target { float4 albedo = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv); clip(albedo.a - 0.5); return albedo; } ENDHLSL } } } Noise Now if you click on Play button again, you will see a grid of grass instances, all sitting peacefully, no animation, no position offset, not fit for our goal.\nControl Map We can add multiple noise texture to randomize and control all the grass properties, for example, position, desity, scale, and height.\n_PositionTex(\"Position Offset\", 2D) = \"white\" {} _DensityTex(\"Density\", 2D) = \"white\" {} _ScaleTex(\"Scale\", 2D) = \"white\" {} _HeightTex(\"Height\", 2D) = \"white\" {} But as you probably noticed, most of the properties only require a float value, which means each of them is only going to take one channel to store the data. We can store all the one-channel data into RGBA respectively in a single texture called _ControlTex:\n_ControlTex(\"Control\", 2D) = \"white\" {}//R: Position Offset, G: Density, B: Scale, A: Height To use the texture, we can use the normalized 2D instance ID we calculated before as the UV to sample the texture:\nfloat4 control = SAMPLE_TEXTURE2D_LOD(_ControlTex, sampler_ControlTex, instanceID2D01, 0); //control.r: position offset //control.g: density //control.b: scale //control.a: height Now we got a float4 control value for that vertex instance, we can then use it to control the position, density, scale, and height of the grass instance later.\nWind Map For wind effect, we can use another scrolling continuous noise texture to simulate the wind effect, four channels of the texture can be used to control the wind effect in different directions and the scale if the grass instance.\n_NoiseTex (\"Noise (RGBA)\", 2D) = \"white\" {}//R: PosX, G: PosY, B: PosZ, A: Scale UNITY_INSTANCING_BUFFER_START(Props) ... UNITY_DEFINE_INSTANCED_PROP(float4, _SwingScale) UNITY_DEFINE_INSTANCED_PROP(float, _Speed) ... UNITY_DEFINE_INSTANCED_END(Props) float4 noise = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, instanceID2D01 + _Time.xy * _Speed, 0); Now we got another float4 noise value for wind.\nFinal Shader Putting all the pieces together, we get the final shader:\nShader \"Hidden/XiheRendering/BillboardGrassUnlit\" { Properties { _MainTex (\"Albedo (RGB)\", 2D) = \"white\" {} _ControlTex (\"Control (RGBA)\", 2D) = \"white\" {}//R: Position Offset, G: Density, B: Scale, A: Height _NoiseTex (\"Noise (RGBA)\", 2D) = \"white\" {}//R: PosX, G: PosY, B: PosZ, A: Scale } SubShader { Cull Off Zwrite On Pass { Name \"BillboardGrassForward\" Tags { \"LightMode\" = \"UniversalForward\" } Blend SrcAlpha OneMinusSrcAlpha HLSLPROGRAM #pragma vertex Vertex #pragma fragment Fragment #pragma target 4.5 #pragma multi_compile_instancing #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\" #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\" UNITY_INSTANCING_BUFFER_START(Props) UNITY_DEFINE_INSTANCED_PROP(float4, _Dimension) //x: dimensionX, y: dimensionZ, z: densityX, w: densityZ UNITY_DEFINE_INSTANCED_PROP(float, _DimensionY) UNITY_DEFINE_INSTANCED_PROP(float4, _ControlNoiseScale) UNITY_DEFINE_INSTANCED_PROP(float4, _SwingScale) UNITY_DEFINE_INSTANCED_PROP(float, _Speed) UNITY_INSTANCING_BUFFER_END(Props) TEXTURE2D(_MainTex); SAMPLER(sampler_MainTex); //R: PosX, G: PosZ, B: Scale, A: Height TEXTURE2D(_ControlTex); SAMPLER(sampler_ControlTex); //R: PosX, G: PosY, B: PosZ, A: Scale TEXTURE2D(_NoiseTex); SAMPLER(sampler_NoiseTex); struct Attributes { float4 vertex : POSITION; float4 uv : TEXCOORD0; }; struct Varyings { float4 positionHCS : SV_POSITION; float2 uv : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; Varyings Vertex(Attributes IN, uint instanceID : SV_InstanceID) { float dimensionZ = floor(_Dimension.y * _Dimension.w); //actual number of instances allowed on z-axis float offsetX = floor(instanceID / dimensionZ) / _Dimension.z; float offsetZ = instanceID % dimensionZ / _Dimension.w; float3 localPosition = IN.vertex.xyz; // float2 instanceID2D01 = float2(offsetX / _Dimension.x, offsetZ / _Dimension.y); float2 instanceID2D01 = float2(offsetX / _Dimension.x, offsetZ / _Dimension.y); //R: Pos Noise, G: Scale Noise, B: Density, A: Height float4 control = SAMPLE_TEXTURE2D_LOD(_ControlTex, sampler_ControlTex, instanceID2D01, 0); float4 noise = SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, instanceID2D01+_Time.xy*_Speed, 0); localPosition.x += lerp(0, (noise.r * 2 - 1) * _SwingScale.x, IN.uv.x); localPosition.z += lerp(0, (noise.g * 2 - 1) * _SwingScale.z, IN.uv.y); localPosition *= (noise.a * 2 - 1) * _SwingScale.w + 1; localPosition *= step(.5, control.g) * (control.b * 2) * _ControlNoiseScale.z + 1; localPosition.x += (control.r * 2 - 1) * _ControlNoiseScale.x; localPosition.z += (control.r * 2 - 1) * _ControlNoiseScale.y; localPosition.y += -_DimensionY / 2 + control.a * _DimensionY; //calculate world position float3 worldPosition = localPosition - float3(_Dimension.x, 0, _Dimension.y) / 2.0 + float3(offsetX, 0, offsetZ); Varyings o; o.positionHCS = TransformObjectToHClip(worldPosition); o.uv = IN.uv.xy; return o; } float4 Fragment(Varyings IN) : SV_Target { float4 albedo = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv); clip(albedo.a - 0.5); float4 output = albedo; return output; } ENDHLSL } } } Renderer using System; using UnityEngine; using UnityEngine.Rendering; using UnityEngine.Serialization; namespace XiheRendering.Procedural.BillboardGrass { public class BillboardGrassRenderer : MonoBehaviour { public Mesh mesh; public int subMeshIndex = 0; // material public Texture2D colorMap; public Texture2D controlMap; public Texture2D noiseMap; public int layer; public ShadowCastingMode castShadows = ShadowCastingMode.On; public bool receiveShadows = true; // instancing public Vector3 dimension = new Vector3(10, 10, 10); public Vector2 density = new Vector2(100, 100); public Vector4 controlNoiseScale = new Vector4(1, 1, 1, 1); public Vector3 swingScale = new Vector3(1, 1, 1); public float scaleSwingScale = 1; public float swingSpeed = 1; public bool renderInSceneCamera; private Material m_Material; private Vector2 m_CachedDensity = Vector2.zero; private Vector3 m_CachedDimension = Vector3.zero; private Vector4 m_CachedControlNoiseScale = Vector4.zero; private Vector3 m_CachedSwingScale = Vector3.zero; private float m_CachedScaleSwingScale = 0; private float m_CachedSwingSpeed = 0; private Texture2D m_CachedColorMap; private Texture2D m_CachedControlMap; private Texture2D m_CachedNoiseMap; private ComputeBuffer m_ArgsBuffer; private readonly uint[] m_Args = new uint[5] { 0, 0, 0, 0, 0 }; private MaterialPropertyBlock m_PropertyBlock; private static readonly int DimensionAndDensityPropertyID = Shader.PropertyToID(\"_Dimension\"); private static readonly int DimensionYPropertyID = Shader.PropertyToID(\"_DimensionY\"); private static readonly int ColorMapPropertyID = Shader.PropertyToID(\"_MainTex\"); private static readonly int ControlMapPropertyID = Shader.PropertyToID(\"_ControlTex\"); private static readonly int NoiseMapPropertyID = Shader.PropertyToID(\"_NoiseTex\"); private static readonly int SwingSpeedPropertyID = Shader.PropertyToID(\"_Speed\"); private static readonly int ControlNoiseScale = Shader.PropertyToID(\"_ControlNoiseScale\"); private static readonly int SwingScale = Shader.PropertyToID(\"_SwingScale\"); void Start() { m_ArgsBuffer = new ComputeBuffer(1, m_Args.Length * sizeof(uint), ComputeBufferType.IndirectArguments); m_PropertyBlock = new MaterialPropertyBlock(); UpdateBuffers(); } void Update() { // Update starting position buffer if (m_CachedDensity != density || m_CachedDimension != dimension || m_CachedControlNoiseScale != controlNoiseScale || m_CachedSwingScale != swingScale || Math.Abs(m_CachedScaleSwingScale - scaleSwingScale) \u003e float.Epsilon || colorMap != m_CachedColorMap || controlMap != m_CachedControlMap || noiseMap != m_CachedNoiseMap) { UpdateBuffers(); } // Render Graphics.DrawMeshInstancedIndirect(mesh, subMeshIndex, m_Material, new Bounds(transform.position, dimension), m_ArgsBuffer, 0, m_PropertyBlock, castShadows, receiveShadows, layer, renderInSceneCamera ? null : Camera.current); } void UpdateBuffers() { if (mesh == null) { m_Args[0] = m_Args[1] = m_Args[2] = m_Args[3] = 0; m_PropertyBlock.Clear(); Debug.LogWarning(\"You forgot to assign a mesh to GPU grass generator\"); return; } // Ensure submesh index is in range subMeshIndex = Mathf.Clamp(subMeshIndex, 0, mesh.subMeshCount - 1); density = new Vector2(Mathf.Max(0, density.x), Mathf.Max(0, density.y)); dimension = new Vector3(Mathf.Max(0, dimension.x), Mathf.Max(0, dimension.y), Mathf.Max(0, dimension.z)); //set properties if (m_Material == null) { m_Material = new Material(Shader.Find(\"Hidden/XiheRendering/BillboardGrassUnlit\")); } var dimensionAndDensity = new Vector4(dimension.x, dimension.z, density.x, density.y); m_PropertyBlock.SetVector(DimensionAndDensityPropertyID, dimensionAndDensity); m_PropertyBlock.SetFloat(DimensionYPropertyID, dimension.y); m_PropertyBlock.SetTexture(ColorMapPropertyID, colorMap); m_PropertyBlock.SetTexture(ControlMapPropertyID, controlMap); m_PropertyBlock.SetTexture(NoiseMapPropertyID, noiseMap); m_PropertyBlock.SetFloat(SwingSpeedPropertyID, swingSpeed); m_PropertyBlock.SetVector(ControlNoiseScale, controlNoiseScale); m_PropertyBlock.SetVector(SwingScale, new Vector4(swingScale.x, swingScale.y, swingScale.z, scaleSwingScale)); // Args // index count per instance, // instance count, // start index location, // base vertex location, // start instance location. m_Args[0] = (uint)mesh.GetIndexCount(subMeshIndex); m_Args[1] = (uint)Mathf.FloorToInt(density.x * dimension.x * density.y * dimension.z); m_Args[2] = (uint)mesh.GetIndexStart(subMeshIndex); m_Args[3] = (uint)mesh.GetBaseVertex(subMeshIndex); m_ArgsBuffer.SetData(m_Args); m_CachedDensity = density; m_CachedDimension = dimension; } void OnDisable() { if (m_ArgsBuffer != null) m_ArgsBuffer.Release(); m_ArgsBuffer = null; } #if UNITY_EDITOR private void OnDrawGizmos() { //draw bounding box Gizmos.color = Color.red; Gizmos.DrawWireCube(transform.position, dimension); } #endif } } Next Steps As you can see, we have created a GPU instancing grass system…for flat surfaces without any obstacles…, which isn’t very useful. The good thing is that we have implemented the control map and noise map, all that’s left is a tool to generate those maps based on the real environment.\nIn the next post, we will create an tool based on untiy’s EditorWindow to bake the control map and noise map!\n",
  "wordCount" : "2344",
  "inLanguage": "en",
  "datePublished": "2024-03-04T11:59:37-07:00",
  "dateModified": "2024-03-04T11:59:37-07:00",
  "author":{
    "@type": "Person",
    "name": "sky_haihai"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sky-haihai.github.io/Yaotian-Huang/posts/gamedev/create-stylized-gpu-instancing-billboard-grass-without-creating-position-buffer-in-urp/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Yaotian Huang",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sky-haihai.github.io/Yaotian-Huang/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sky-haihai.github.io/Yaotian-Huang/" accesskey="h" title="Yaotian Huang (Alt + H)">Yaotian Huang</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sky-haihai.github.io/Yaotian-Huang/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://sky-haihai.github.io/Yaotian-Huang/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://sky-haihai.github.io/Yaotian-Huang/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://sky-haihai.github.io/Yaotian-Huang/">Home</a>&nbsp;»&nbsp;<a href="https://sky-haihai.github.io/Yaotian-Huang/posts/">Posts</a></div>
    <h1 class="post-title">
      Create Stylized GPU Instancing Billboard Grass Without Creating Position Buffer in URP
    </h1>
    <div class="post-meta">&lt;span title=&#39;2024-03-04 11:59:37 -0700 MST&#39;&gt;March 4, 2024&lt;/span&gt;&amp;nbsp;·&amp;nbsp;12 min&amp;nbsp;·&amp;nbsp;sky_haihai

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#environment" aria-label="Environment">Environment</a></li>
                <li>
                    <a href="#prerequisite" aria-label="Prerequisite">Prerequisite</a></li>
                <li>
                    <a href="#gpu-instancing" aria-label="GPU Instancing">GPU Instancing</a></li>
                <li>
                    <a href="#graphicsdrawmeshinstancedindirect" aria-label="Graphics.DrawMeshInstancedIndirect">Graphics.DrawMeshInstancedIndirect</a></li>
                <li>
                    <a href="#material" aria-label="Material">Material</a><ul>
                        
                <li>
                    <a href="#gpu-instancing-keywords-and-macros" aria-label="GPU Instancing Keywords and Macros">GPU Instancing Keywords and Macros</a></li>
                <li>
                    <a href="#material-property" aria-label="Material Property">Material Property</a></li>
                <li>
                    <a href="#local-position-offset" aria-label="Local Position Offset">Local Position Offset</a></li>
                <li>
                    <a href="#noise-texture-uv" aria-label="Noise Texture UV">Noise Texture UV</a></li>
                <li>
                    <a href="#static-gpu-instancing-grass-shader" aria-label="Static GPU Instancing Grass Shader">Static GPU Instancing Grass Shader</a></li></ul>
                </li>
                <li>
                    <a href="#noise" aria-label="Noise">Noise</a><ul>
                        
                <li>
                    <a href="#control-map" aria-label="Control Map">Control Map</a></li>
                <li>
                    <a href="#wind-map" aria-label="Wind Map">Wind Map</a></li></ul>
                </li>
                <li>
                    <a href="#final" aria-label="Final">Final</a><ul>
                        
                <li>
                    <a href="#shader" aria-label="Shader">Shader</a></li>
                <li>
                    <a href="#renderer" aria-label="Renderer">Renderer</a></li>
                <li>
                    <a href="#next-steps" aria-label="Next Steps">Next Steps</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="environment">Environment<a hidden class="anchor" aria-hidden="true" href="#environment">#</a></h2>
<p>Unity 2021.3.16f1<br>
URP 12.0</p>
<h2 id="prerequisite">Prerequisite<a hidden class="anchor" aria-hidden="true" href="#prerequisite">#</a></h2>
<p>Basic knowledge of C# and Shader programming (HLSL).</p>
<h2 id="gpu-instancing">GPU Instancing<a hidden class="anchor" aria-hidden="true" href="#gpu-instancing">#</a></h2>
<p>GPU instancing is a technique that allows you to draw multiple copies of the same mesh using a single draw call. It is basically normal forward rendering pipeline but skipping the Vertex Specification stage.</p>
<h2 id="graphicsdrawmeshinstancedindirect">Graphics.DrawMeshInstancedIndirect<a hidden class="anchor" aria-hidden="true" href="#graphicsdrawmeshinstancedindirect">#</a></h2>
<p>The first step to create multiple millions of grass is to properly call the GPU to draw so, a.k.a. draw call. In Unity, we can use <code>Graphics.DrawMeshInstancedIndirect</code> to create a GPU instancing draw call.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// Graphics.cs</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> DrawMeshInstancedIndirect(
</span></span><span style="display:flex;"><span>Mesh mesh, <span style="color:#66d9ef">int</span> submeshIndex, Material material, 
</span></span><span style="display:flex;"><span>Bounds bounds, ComputeBuffer bufferWithArgs, 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> argsOffset = <span style="color:#ae81ff">0</span>, MaterialPropertyBlock properties = <span style="color:#66d9ef">null</span>,
</span></span><span style="display:flex;"><span>ShadowCastingMode castShadows = ShadowCastingMode.On, 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> receiveShadows = <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">int</span> layer = <span style="color:#ae81ff">0</span>, 
</span></span><span style="display:flex;"><span>Camera camera = <span style="color:#66d9ef">null</span>, LightProbeUsage lightProbeUsage = LightProbeUsage.BlendProbes, 
</span></span><span style="display:flex;"><span>LightProbeProxyVolume lightProbeProxyVolume = <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>Most of the parameters are self-explanatory. The <code>ComputeBuffer bufferWithArgs</code> is the most important one. It is a buffer that contains the arguments for the draw call. This has to be exacly a 5 elements long int array.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span>[] args = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">5</span>] { <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span> };
</span></span></code></pre></div><p>The five arguments that we are going to fill inside this int array are:</p>
<ol>
<li>the number of instances</li>
<li>the number of instances to draw</li>
<li>the start instance location</li>
<li>the base vertex location</li>
<li>the start index location</li>
</ol>
<p>With the knowledge above, we can create a simple script to draw a single mesh with GPU instancing.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> UnityEngine;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BillboardGrassRenderer</span> : MonoBehaviour
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Mesh mesh;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> subMeshIndex = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> instanceCount = <span style="color:#ae81ff">1000</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Vector3 dimension = <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Vector2 density = <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Material m_Material;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> MaterialPropertyBlock m_PropertyBlock = <span style="color:#66d9ef">new</span> MaterialPropertyBlock();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> ComputeBuffer m_ArgsBuffer;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">uint</span>[] m_Args = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">uint</span>[<span style="color:#ae81ff">5</span>] { <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> Start()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        m_ArgsBuffer = <span style="color:#66d9ef">new</span> ComputeBuffer(<span style="color:#ae81ff">1</span>, m_Args.Length * <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">uint</span>), ComputeBufferType.IndirectArguments);
</span></span><span style="display:flex;"><span>        m_Args[<span style="color:#ae81ff">0</span>] = (<span style="color:#66d9ef">uint</span>)mesh.GetIndexCount(subMeshIndex);
</span></span><span style="display:flex;"><span>        m_Args[<span style="color:#ae81ff">1</span>] = (<span style="color:#66d9ef">uint</span>)instanceCount;
</span></span><span style="display:flex;"><span>        m_Args[<span style="color:#ae81ff">2</span>] = (<span style="color:#66d9ef">uint</span>)mesh.GetIndexStart(subMeshIndex);
</span></span><span style="display:flex;"><span>        m_Args[<span style="color:#ae81ff">3</span>] = (<span style="color:#66d9ef">uint</span>)mesh.GetBaseVertex(subMeshIndex);
</span></span><span style="display:flex;"><span>        m_Args[<span style="color:#ae81ff">4</span>] = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        m_ArgsBuffer.SetData(m_Args);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> dimensionAndDensity = <span style="color:#66d9ef">new</span> Vector4(dimension.x, dimension.z, density.x, density.y);
</span></span><span style="display:flex;"><span>        m_PropertyBlock.SetVector(DimensionAndDensityPropertyID, dimensionAndDensity);
</span></span><span style="display:flex;"><span>        m_Material = <span style="color:#66d9ef">new</span> Material(Shader.Find(<span style="color:#e6db74">&#34;Universal Render Pipeline/Lit&#34;</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> Update()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Graphics.DrawMeshInstancedIndirect(mesh, subMeshIndex, m_Material, <span style="color:#66d9ef">new</span> Bounds(transform.position, dimension), m_ArgsBuffer, <span style="color:#ae81ff">0</span>, m_PropertyBlock);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> OnDisable()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (m_ArgsBuffer != <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            m_ArgsBuffer.Release();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        _argsBuffer = <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="material">Material<a hidden class="anchor" aria-hidden="true" href="#material">#</a></h2>
<p>As you probably noticed in the script, the grass material is currently using URP/Lit as its shader. As we didn&rsquo;t compute the grass positions anywhere, the grass will be drawn at the origin. We can fix this in two ways:</p>
<ol>
<li>Compute position info in the shader</li>
<li>Use a compute shader to calculate the positions, and a compute buffer to store the positions info and pass it to the shader.</li>
</ol>
<p>The difference between the two methods is that the first method is more efficient as there&rsquo;s no need to pass the information around between CPU and GPU , but the second method is more flexible. We will use the first method in this tutorial.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span>Shader <span style="color:#e6db74">&#34;Hidden/XiheRendering/BillboardGrassUnlit&#34;</span> {
</span></span><span style="display:flex;"><span>    Properties {
</span></span><span style="display:flex;"><span>        _MainTex (<span style="color:#e6db74">&#34;Albedo (RGB)&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    SubShader {
</span></span><span style="display:flex;"><span>        Cull Off
</span></span><span style="display:flex;"><span>        Zwrite On
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Pass {
</span></span><span style="display:flex;"><span>            Name <span style="color:#e6db74">&#34;BillboardGrassForward&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Tags {
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;LightMode&#34;</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;UniversalForward&#34;</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            HLSLPROGRAM
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>pragma vertex Vertex
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>pragma fragment Fragment
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#e6db74">&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#e6db74">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            TEXTURE2D(_MainTex);
</span></span><span style="display:flex;"><span>            SAMPLER(sampler_MainTex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">struct</span> Attributes
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float4</span> vertex <span style="color:#f92672">:</span> POSITION;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float4</span> uv <span style="color:#f92672">:</span> TEXCOORD0;
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">struct</span> Varyings
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float4</span> positionHCS <span style="color:#f92672">:</span> SV_POSITION;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float2</span> uv <span style="color:#f92672">:</span> TEXCOORD0;
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Varyings Vertex(Attributes IN, <span style="color:#66d9ef">uint</span> instanceID <span style="color:#f92672">:</span> <span style="color:#a6e22e">SV_InstanceID</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Varyings o;
</span></span><span style="display:flex;"><span>                o.positionHCS <span style="color:#f92672">=</span> TransformObjectToHClip(IN.vertex.xyz);
</span></span><span style="display:flex;"><span>                o.uv <span style="color:#f92672">=</span> IN.uv.xy;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> o;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">float4</span> Fragment(Varyings IN) <span style="color:#f92672">:</span> <span style="color:#a6e22e">SV_Target</span>
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float4</span> albedo <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
</span></span><span style="display:flex;"><span>                clip(albedo.a <span style="color:#f92672">-</span> <span style="color:#ae81ff">0.5</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> albedo;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            ENDHLSL
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="gpu-instancing-keywords-and-macros">GPU Instancing Keywords and Macros<a hidden class="anchor" aria-hidden="true" href="#gpu-instancing-keywords-and-macros">#</a></h3>
<p>First thing is first, in order to let the shader support GPU instancing, we need to add <code>#pragma multi_compile_instancing</code> to the shader. This will tell the shader to generate multiple shader variants for each instance.</p>
<p>All keywords and macros can be found here: <a href="https://docs.unity3d.com/Manual/gpu-instancing-shader.html">Creating shaders that support GPU instancing</a>.</p>
<h3 id="material-property">Material Property<a hidden class="anchor" aria-hidden="true" href="#material-property">#</a></h3>
<p>In this basic shader, we first declare the <code>_Dimension</code> property inside the <code>UNITY_INSTANCING_BUFFER_START</code> and <code>UNITY_INSTANCING_BUFFER_END</code> macros.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span>UNITY_INSTANCING_BUFFER_START(Props)
</span></span><span style="display:flex;"><span>    UNITY_DEFINE_INSTANCED_PROP(<span style="color:#66d9ef">float4</span>, _Dimension) <span style="color:#75715e">//x: dimensionX, y: dimensionZ, z: densityX, w: densityZ</span>
</span></span><span style="display:flex;"><span>UNITY_INSTANCING_BUFFER_END(Props)
</span></span></code></pre></div><p><code>UNITY_INSTANCING_BUFFER</code> is a per-instance type of CBUFFER which will receive values from MaterialPropertyBlock from C# side.</p>
<p>We will use this property to calculate a 2D(XZ) position offset(similar to DispatchThreadID) of the grass instance. Let&rsquo;s first draw a grass instance every 1 meter on the x-axis and 1 meter on the z-axis. We can then calculate the offset distance for each instance on the x and z axis using the instance ID and the <code>_Dimension</code> property.</p>
<ul>
<li>_Dimension.x: dimension of the grass bounding volume on the x-axis</li>
<li>_Dimension.y: dimension of the grass bounding volume on the z-axis</li>
<li>_Dimension.z: density of the grass per meter on the x-axis</li>
<li>_Dimension.w: density of the grass per meter on the z-axis</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span><span style="color:#75715e">//actual number of instances allowed on z-axis</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> dimensionZ <span style="color:#f92672">=</span> floor(_Dimension.y <span style="color:#f92672">*</span> _Dimension.w);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> offsetX <span style="color:#f92672">=</span> floor(instanceID <span style="color:#f92672">/</span> dimensionZ) <span style="color:#f92672">/</span> _Dimension.z;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> offsetZ <span style="color:#f92672">=</span> instanceID <span style="color:#f92672">%</span> dimensionZ <span style="color:#f92672">/</span> _Dimension.w;
</span></span></code></pre></div><h3 id="local-position-offset">Local Position Offset<a hidden class="anchor" aria-hidden="true" href="#local-position-offset">#</a></h3>
<p>Now we got offset distance for each instance on the x and z axis, add the offset to the origin position and subtract half of the bounding volume to get a local position from the left, backward corner of the bounding volume:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span><span style="color:#66d9ef">float3</span> localPositionOffset <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>localPosition <span style="color:#f92672">-</span> <span style="color:#66d9ef">float3</span>(_Dimension.x, <span style="color:#ae81ff">0</span>, _Dimension.y) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">float3</span>(offsetX, <span style="color:#ae81ff">0</span>, offsetZ);
</span></span></code></pre></div><h3 id="noise-texture-uv">Noise Texture UV<a hidden class="anchor" aria-hidden="true" href="#noise-texture-uv">#</a></h3>
<p>We can also calculate the normalized offset to get a grass-bounding-box-space UV for sampling scrolling noise textures later, x-axis is the offsetX, y-axis is the offsetZ. We can use this UV to sample the noise texture later to add some wind effect to the grass.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span><span style="color:#75715e">//normalized instance ID in 2D space</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float2</span> instanceID2D01 <span style="color:#f92672">=</span> <span style="color:#66d9ef">float2</span>(offsetX <span style="color:#f92672">/</span> _Dimension.x, offsetZ <span style="color:#f92672">/</span> _Dimension.y);
</span></span></code></pre></div><h3 id="static-gpu-instancing-grass-shader">Static GPU Instancing Grass Shader<a hidden class="anchor" aria-hidden="true" href="#static-gpu-instancing-grass-shader">#</a></h3>
<p>Putting all the pieces together, we get the following shader:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span>Shader <span style="color:#e6db74">&#34;Hidden/XiheRendering/BillboardGrassUnlit&#34;</span> {
</span></span><span style="display:flex;"><span>    Properties {
</span></span><span style="display:flex;"><span>        _MainTex (<span style="color:#e6db74">&#34;Albedo (RGB)&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    SubShader {
</span></span><span style="display:flex;"><span>        Cull Off
</span></span><span style="display:flex;"><span>        Zwrite On
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Pass {
</span></span><span style="display:flex;"><span>            Name <span style="color:#e6db74">&#34;BillboardGrassForward&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Tags {
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;LightMode&#34;</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;UniversalForward&#34;</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            HLSLPROGRAM
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>pragma vertex Vertex
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>pragma fragment Fragment
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>pragma target <span style="color:#ae81ff">4.5</span>
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>pragma multi_compile_instancing
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#e6db74">&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#e6db74">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            UNITY_INSTANCING_BUFFER_START(Props)
</span></span><span style="display:flex;"><span>                UNITY_DEFINE_INSTANCED_PROP(<span style="color:#66d9ef">float4</span>, _Dimension) <span style="color:#75715e">//x: dimensionX, y: dimensionZ, z: densityX, w: densityZ</span>
</span></span><span style="display:flex;"><span>            UNITY_INSTANCING_BUFFER_END(Props)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            TEXTURE2D(_MainTex);
</span></span><span style="display:flex;"><span>            SAMPLER(sampler_MainTex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">struct</span> Attributes
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float4</span> vertex <span style="color:#f92672">:</span> POSITION;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float4</span> uv <span style="color:#f92672">:</span> TEXCOORD0;
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">struct</span> Varyings
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float4</span> positionHCS <span style="color:#f92672">:</span> SV_POSITION;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float2</span> uv <span style="color:#f92672">:</span> TEXCOORD0;
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Varyings Vertex(Attributes IN, <span style="color:#66d9ef">uint</span> instanceID <span style="color:#f92672">:</span> <span style="color:#a6e22e">SV_InstanceID</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float</span> dimensionZ <span style="color:#f92672">=</span> floor(_Dimension.y <span style="color:#f92672">*</span> _Dimension.w); <span style="color:#75715e">//actual number of instances allowed on z-axis</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float</span> offsetX <span style="color:#f92672">=</span> floor(instanceID <span style="color:#f92672">/</span> dimensionZ) <span style="color:#f92672">/</span> _Dimension.z;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float</span> offsetZ <span style="color:#f92672">=</span> instanceID <span style="color:#f92672">%</span> dimensionZ <span style="color:#f92672">/</span> _Dimension.w;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float3</span> localPosition <span style="color:#f92672">=</span> IN.vertex.xyz;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float2</span> instanceID2D01 <span style="color:#f92672">=</span> <span style="color:#66d9ef">float2</span>(offsetX <span style="color:#f92672">/</span> _Dimension.x, offsetZ <span style="color:#f92672">/</span> _Dimension.y);<span style="color:#75715e">//no use for now, use this to sample noise later </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float3</span> localPositionOffset <span style="color:#f92672">=</span> localPosition <span style="color:#f92672">-</span> <span style="color:#66d9ef">float3</span>(_Dimension.x, <span style="color:#ae81ff">0</span>, _Dimension.y) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">float3</span>(offsetX, <span style="color:#ae81ff">0</span>, offsetZ);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Varyings o;
</span></span><span style="display:flex;"><span>                o.positionHCS <span style="color:#f92672">=</span> TransformObjectToHClip(localPositionOffset);
</span></span><span style="display:flex;"><span>                o.uv <span style="color:#f92672">=</span> IN.uv.xy;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> o;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">float4</span> Fragment(Varyings IN) <span style="color:#f92672">:</span> <span style="color:#a6e22e">SV_Target</span>
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float4</span> albedo <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
</span></span><span style="display:flex;"><span>                clip(albedo.a <span style="color:#f92672">-</span> <span style="color:#ae81ff">0.5</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> albedo;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            ENDHLSL
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="noise">Noise<a hidden class="anchor" aria-hidden="true" href="#noise">#</a></h2>
<p>Now if you click on Play button again, you will see a grid of grass instances, all sitting peacefully, no animation, no position offset, not fit for our goal.</p>
<h3 id="control-map">Control Map<a hidden class="anchor" aria-hidden="true" href="#control-map">#</a></h3>
<p>We can add multiple noise texture to randomize and control all the grass properties, for example, position, desity, scale, and height.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span>_PositionTex(<span style="color:#e6db74">&#34;Position Offset&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {}
</span></span><span style="display:flex;"><span>_DensityTex(<span style="color:#e6db74">&#34;Density&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {}
</span></span><span style="display:flex;"><span>_ScaleTex(<span style="color:#e6db74">&#34;Scale&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {}
</span></span><span style="display:flex;"><span>_HeightTex(<span style="color:#e6db74">&#34;Height&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {}
</span></span></code></pre></div><p>But as you probably noticed, most of the properties only require a float value, which means each of them is only going to take one channel to store the data. We can store all the one-channel data into RGBA respectively in a single texture called <code>_ControlTex</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span>_ControlTex(<span style="color:#e6db74">&#34;Control&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {}<span style="color:#75715e">//R: Position Offset, G: Density, B: Scale, A: Height</span>
</span></span></code></pre></div><p>To use the texture, we can use the normalized 2D instance ID we calculated before as the UV to sample the texture:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span><span style="color:#66d9ef">float4</span> control <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D_LOD(_ControlTex, sampler_ControlTex, instanceID2D01, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//control.r: position offset</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//control.g: density</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//control.b: scale</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//control.a: height</span>
</span></span></code></pre></div><p>Now we got a float4 control value for that vertex instance, we can then use it to control the position, density, scale, and height of the grass instance later.</p>
<h3 id="wind-map">Wind Map<a hidden class="anchor" aria-hidden="true" href="#wind-map">#</a></h3>
<p>For wind effect, we can use another scrolling continuous noise texture to simulate the wind effect, four channels of the texture can be used to control the wind effect in different directions and the scale if the grass instance.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span>_NoiseTex (<span style="color:#e6db74">&#34;Noise (RGBA)&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {}<span style="color:#75715e">//R: PosX, G: PosY, B: PosZ, A: Scale</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span>UNITY_INSTANCING_BUFFER_START(Props)
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    UNITY_DEFINE_INSTANCED_PROP(<span style="color:#66d9ef">float4</span>, _SwingScale)
</span></span><span style="display:flex;"><span>    UNITY_DEFINE_INSTANCED_PROP(<span style="color:#66d9ef">float</span>, _Speed)
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>UNITY_DEFINE_INSTANCED_END(Props)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span><span style="color:#66d9ef">float4</span> noise <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, instanceID2D01 <span style="color:#f92672">+</span> _Time.xy <span style="color:#f92672">*</span> _Speed, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>Now we got another float4 noise value for wind.</p>
<h2 id="final">Final<a hidden class="anchor" aria-hidden="true" href="#final">#</a></h2>
<h3 id="shader">Shader<a hidden class="anchor" aria-hidden="true" href="#shader">#</a></h3>
<p>Putting all the pieces together, we get the final shader:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hlsl" data-lang="hlsl"><span style="display:flex;"><span>Shader <span style="color:#e6db74">&#34;Hidden/XiheRendering/BillboardGrassUnlit&#34;</span> {
</span></span><span style="display:flex;"><span>    Properties {
</span></span><span style="display:flex;"><span>        _MainTex (<span style="color:#e6db74">&#34;Albedo (RGB)&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {}
</span></span><span style="display:flex;"><span>        _ControlTex (<span style="color:#e6db74">&#34;Control (RGBA)&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {}<span style="color:#75715e">//R: Position Offset, G: Density, B: Scale, A: Height</span>
</span></span><span style="display:flex;"><span>        _NoiseTex (<span style="color:#e6db74">&#34;Noise (RGBA)&#34;</span>, <span style="color:#ae81ff">2</span>D) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;white&#34;</span> {}<span style="color:#75715e">//R: PosX, G: PosY, B: PosZ, A: Scale</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    SubShader {
</span></span><span style="display:flex;"><span>        Cull Off
</span></span><span style="display:flex;"><span>        Zwrite On
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Pass {
</span></span><span style="display:flex;"><span>            Name <span style="color:#e6db74">&#34;BillboardGrassForward&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Tags {
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;LightMode&#34;</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;UniversalForward&#34;</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Blend SrcAlpha OneMinusSrcAlpha
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            HLSLPROGRAM
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>pragma vertex Vertex
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>pragma fragment Fragment
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>pragma target <span style="color:#ae81ff">4.5</span>
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>pragma multi_compile_instancing
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#e6db74">&#34;Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">#</span>include <span style="color:#e6db74">&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            UNITY_INSTANCING_BUFFER_START(Props)
</span></span><span style="display:flex;"><span>                UNITY_DEFINE_INSTANCED_PROP(<span style="color:#66d9ef">float4</span>, _Dimension) <span style="color:#75715e">//x: dimensionX, y: dimensionZ, z: densityX, w: densityZ</span>
</span></span><span style="display:flex;"><span>                UNITY_DEFINE_INSTANCED_PROP(<span style="color:#66d9ef">float</span>, _DimensionY)
</span></span><span style="display:flex;"><span>                UNITY_DEFINE_INSTANCED_PROP(<span style="color:#66d9ef">float4</span>, _ControlNoiseScale)
</span></span><span style="display:flex;"><span>                UNITY_DEFINE_INSTANCED_PROP(<span style="color:#66d9ef">float4</span>, _SwingScale)
</span></span><span style="display:flex;"><span>                UNITY_DEFINE_INSTANCED_PROP(<span style="color:#66d9ef">float</span>, _Speed)
</span></span><span style="display:flex;"><span>            UNITY_INSTANCING_BUFFER_END(Props)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            TEXTURE2D(_MainTex);
</span></span><span style="display:flex;"><span>            SAMPLER(sampler_MainTex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//R: PosX, G: PosZ, B: Scale, A: Height</span>
</span></span><span style="display:flex;"><span>            TEXTURE2D(_ControlTex);
</span></span><span style="display:flex;"><span>            SAMPLER(sampler_ControlTex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//R: PosX, G: PosY, B: PosZ, A: Scale</span>
</span></span><span style="display:flex;"><span>            TEXTURE2D(_NoiseTex);
</span></span><span style="display:flex;"><span>            SAMPLER(sampler_NoiseTex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">struct</span> Attributes
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float4</span> vertex <span style="color:#f92672">:</span> POSITION;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float4</span> uv <span style="color:#f92672">:</span> TEXCOORD0;
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">struct</span> Varyings
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float4</span> positionHCS <span style="color:#f92672">:</span> SV_POSITION;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float2</span> uv <span style="color:#f92672">:</span> TEXCOORD0;
</span></span><span style="display:flex;"><span>                UNITY_VERTEX_INPUT_INSTANCE_ID
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Varyings Vertex(Attributes IN, <span style="color:#66d9ef">uint</span> instanceID <span style="color:#f92672">:</span> <span style="color:#a6e22e">SV_InstanceID</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float</span> dimensionZ <span style="color:#f92672">=</span> floor(_Dimension.y <span style="color:#f92672">*</span> _Dimension.w); <span style="color:#75715e">//actual number of instances allowed on z-axis</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float</span> offsetX <span style="color:#f92672">=</span> floor(instanceID <span style="color:#f92672">/</span> dimensionZ) <span style="color:#f92672">/</span> _Dimension.z;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float</span> offsetZ <span style="color:#f92672">=</span> instanceID <span style="color:#f92672">%</span> dimensionZ <span style="color:#f92672">/</span> _Dimension.w;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float3</span> localPosition <span style="color:#f92672">=</span> IN.vertex.xyz;
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// float2 instanceID2D01 = float2(offsetX / _Dimension.x, offsetZ / _Dimension.y);</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float2</span> instanceID2D01 <span style="color:#f92672">=</span> <span style="color:#66d9ef">float2</span>(offsetX <span style="color:#f92672">/</span> _Dimension.x, offsetZ <span style="color:#f92672">/</span> _Dimension.y);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//R: Pos Noise, G: Scale Noise, B: Density, A: Height</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float4</span> control <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D_LOD(_ControlTex, sampler_ControlTex, instanceID2D01, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float4</span> noise <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D_LOD(_NoiseTex, sampler_NoiseTex, instanceID2D01<span style="color:#f92672">+</span>_Time.xy<span style="color:#f92672">*</span>_Speed, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                localPosition.x <span style="color:#f92672">+=</span> lerp(<span style="color:#ae81ff">0</span>, (noise.r <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> _SwingScale.x, IN.uv.x);
</span></span><span style="display:flex;"><span>                localPosition.z <span style="color:#f92672">+=</span> lerp(<span style="color:#ae81ff">0</span>, (noise.g <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> _SwingScale.z, IN.uv.y);
</span></span><span style="display:flex;"><span>                localPosition <span style="color:#f92672">*=</span> (noise.a <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> _SwingScale.w <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                localPosition <span style="color:#f92672">*=</span> step(.<span style="color:#ae81ff">5</span>, control.g) <span style="color:#f92672">*</span> (control.b <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">*</span> _ControlNoiseScale.z <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                localPosition.x <span style="color:#f92672">+=</span> (control.r <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> _ControlNoiseScale.x;
</span></span><span style="display:flex;"><span>                localPosition.z <span style="color:#f92672">+=</span> (control.r <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> _ControlNoiseScale.y;
</span></span><span style="display:flex;"><span>                localPosition.y <span style="color:#f92672">+=</span> <span style="color:#f92672">-</span>_DimensionY <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> control.a <span style="color:#f92672">*</span> _DimensionY;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//calculate world position                </span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float3</span> worldPosition <span style="color:#f92672">=</span> localPosition <span style="color:#f92672">-</span> <span style="color:#66d9ef">float3</span>(_Dimension.x, <span style="color:#ae81ff">0</span>, _Dimension.y) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">float3</span>(offsetX, <span style="color:#ae81ff">0</span>, offsetZ);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Varyings o;
</span></span><span style="display:flex;"><span>                o.positionHCS <span style="color:#f92672">=</span> TransformObjectToHClip(worldPosition);
</span></span><span style="display:flex;"><span>                o.uv <span style="color:#f92672">=</span> IN.uv.xy;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> o;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">float4</span> Fragment(Varyings IN) <span style="color:#f92672">:</span> <span style="color:#a6e22e">SV_Target</span>
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float4</span> albedo <span style="color:#f92672">=</span> SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv);
</span></span><span style="display:flex;"><span>                clip(albedo.a <span style="color:#f92672">-</span> <span style="color:#ae81ff">0.5</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">float4</span> output <span style="color:#f92672">=</span> albedo;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> output;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            ENDHLSL
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="renderer">Renderer<a hidden class="anchor" aria-hidden="true" href="#renderer">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> UnityEngine;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> UnityEngine.Rendering;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> UnityEngine.Serialization;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> XiheRendering.Procedural.BillboardGrass {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BillboardGrassRenderer</span> : MonoBehaviour {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> Mesh mesh;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> subMeshIndex = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// material</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> Texture2D colorMap;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> Texture2D controlMap;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> Texture2D noiseMap;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> layer;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> ShadowCastingMode castShadows = ShadowCastingMode.On;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> receiveShadows = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// instancing</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> Vector3 dimension = <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> Vector2 density = <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> Vector4 controlNoiseScale = <span style="color:#66d9ef">new</span> Vector4(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> Vector3 swingScale = <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">float</span> scaleSwingScale = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">float</span> swingSpeed = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> renderInSceneCamera;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> Material m_Material;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> Vector2 m_CachedDensity = Vector2.zero;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> Vector3 m_CachedDimension = Vector3.zero;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> Vector4 m_CachedControlNoiseScale = Vector4.zero;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> Vector3 m_CachedSwingScale = Vector3.zero;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">float</span> m_CachedScaleSwingScale = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">float</span> m_CachedSwingSpeed = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> Texture2D m_CachedColorMap;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> Texture2D m_CachedControlMap;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> Texture2D m_CachedNoiseMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> ComputeBuffer m_ArgsBuffer;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">uint</span>[] m_Args = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">uint</span>[<span style="color:#ae81ff">5</span>] { <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span> };
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> MaterialPropertyBlock m_PropertyBlock;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">int</span> DimensionAndDensityPropertyID = Shader.PropertyToID(<span style="color:#e6db74">&#34;_Dimension&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">int</span> DimensionYPropertyID = Shader.PropertyToID(<span style="color:#e6db74">&#34;_DimensionY&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">int</span> ColorMapPropertyID = Shader.PropertyToID(<span style="color:#e6db74">&#34;_MainTex&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">int</span> ControlMapPropertyID = Shader.PropertyToID(<span style="color:#e6db74">&#34;_ControlTex&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">int</span> NoiseMapPropertyID = Shader.PropertyToID(<span style="color:#e6db74">&#34;_NoiseTex&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">int</span> SwingSpeedPropertyID = Shader.PropertyToID(<span style="color:#e6db74">&#34;_Speed&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">int</span> ControlNoiseScale = Shader.PropertyToID(<span style="color:#e6db74">&#34;_ControlNoiseScale&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">int</span> SwingScale = Shader.PropertyToID(<span style="color:#e6db74">&#34;_SwingScale&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> Start() {
</span></span><span style="display:flex;"><span>            m_ArgsBuffer = <span style="color:#66d9ef">new</span> ComputeBuffer(<span style="color:#ae81ff">1</span>, m_Args.Length * <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">uint</span>), ComputeBufferType.IndirectArguments);
</span></span><span style="display:flex;"><span>            m_PropertyBlock = <span style="color:#66d9ef">new</span> MaterialPropertyBlock();
</span></span><span style="display:flex;"><span>            UpdateBuffers();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> Update() {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Update starting position buffer</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (m_CachedDensity != density || m_CachedDimension != dimension || m_CachedControlNoiseScale != controlNoiseScale || m_CachedSwingScale != swingScale ||
</span></span><span style="display:flex;"><span>                Math.Abs(m_CachedScaleSwingScale - scaleSwingScale) &gt; <span style="color:#66d9ef">float</span>.Epsilon || colorMap != m_CachedColorMap || controlMap != m_CachedControlMap ||
</span></span><span style="display:flex;"><span>                noiseMap != m_CachedNoiseMap) {
</span></span><span style="display:flex;"><span>                UpdateBuffers();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Render</span>
</span></span><span style="display:flex;"><span>            Graphics.DrawMeshInstancedIndirect(mesh, subMeshIndex, m_Material, <span style="color:#66d9ef">new</span> Bounds(transform.position, dimension), m_ArgsBuffer, <span style="color:#ae81ff">0</span>, m_PropertyBlock,
</span></span><span style="display:flex;"><span>                castShadows, receiveShadows, layer, renderInSceneCamera ? <span style="color:#66d9ef">null</span> : Camera.current);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> UpdateBuffers() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (mesh == <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                m_Args[<span style="color:#ae81ff">0</span>] = m_Args[<span style="color:#ae81ff">1</span>] = m_Args[<span style="color:#ae81ff">2</span>] = m_Args[<span style="color:#ae81ff">3</span>] = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                m_PropertyBlock.Clear();
</span></span><span style="display:flex;"><span>                Debug.LogWarning(<span style="color:#e6db74">&#34;You forgot to assign a mesh to GPU grass generator&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Ensure submesh index is in range</span>
</span></span><span style="display:flex;"><span>            subMeshIndex = Mathf.Clamp(subMeshIndex, <span style="color:#ae81ff">0</span>, mesh.subMeshCount - <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            density = <span style="color:#66d9ef">new</span> Vector2(Mathf.Max(<span style="color:#ae81ff">0</span>, density.x), Mathf.Max(<span style="color:#ae81ff">0</span>, density.y));
</span></span><span style="display:flex;"><span>            dimension = <span style="color:#66d9ef">new</span> Vector3(Mathf.Max(<span style="color:#ae81ff">0</span>, dimension.x), Mathf.Max(<span style="color:#ae81ff">0</span>, dimension.y), Mathf.Max(<span style="color:#ae81ff">0</span>, dimension.z));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//set properties</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (m_Material == <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>                m_Material = <span style="color:#66d9ef">new</span> Material(Shader.Find(<span style="color:#e6db74">&#34;Hidden/XiheRendering/BillboardGrassUnlit&#34;</span>));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> dimensionAndDensity = <span style="color:#66d9ef">new</span> Vector4(dimension.x, dimension.z, density.x, density.y);
</span></span><span style="display:flex;"><span>            m_PropertyBlock.SetVector(DimensionAndDensityPropertyID, dimensionAndDensity);
</span></span><span style="display:flex;"><span>            m_PropertyBlock.SetFloat(DimensionYPropertyID, dimension.y);
</span></span><span style="display:flex;"><span>            m_PropertyBlock.SetTexture(ColorMapPropertyID, colorMap);
</span></span><span style="display:flex;"><span>            m_PropertyBlock.SetTexture(ControlMapPropertyID, controlMap);
</span></span><span style="display:flex;"><span>            m_PropertyBlock.SetTexture(NoiseMapPropertyID, noiseMap);
</span></span><span style="display:flex;"><span>            m_PropertyBlock.SetFloat(SwingSpeedPropertyID, swingSpeed);
</span></span><span style="display:flex;"><span>            m_PropertyBlock.SetVector(ControlNoiseScale, controlNoiseScale);
</span></span><span style="display:flex;"><span>            m_PropertyBlock.SetVector(SwingScale, <span style="color:#66d9ef">new</span> Vector4(swingScale.x, swingScale.y, swingScale.z, scaleSwingScale));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Args</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// index count per instance,</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// instance count,</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// start index location,</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// base vertex location,</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// start instance location.</span>
</span></span><span style="display:flex;"><span>            m_Args[<span style="color:#ae81ff">0</span>] = (<span style="color:#66d9ef">uint</span>)mesh.GetIndexCount(subMeshIndex);
</span></span><span style="display:flex;"><span>            m_Args[<span style="color:#ae81ff">1</span>] = (<span style="color:#66d9ef">uint</span>)Mathf.FloorToInt(density.x * dimension.x * density.y * dimension.z);
</span></span><span style="display:flex;"><span>            m_Args[<span style="color:#ae81ff">2</span>] = (<span style="color:#66d9ef">uint</span>)mesh.GetIndexStart(subMeshIndex);
</span></span><span style="display:flex;"><span>            m_Args[<span style="color:#ae81ff">3</span>] = (<span style="color:#66d9ef">uint</span>)mesh.GetBaseVertex(subMeshIndex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            m_ArgsBuffer.SetData(m_Args);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            m_CachedDensity = density;
</span></span><span style="display:flex;"><span>            m_CachedDimension = dimension;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> OnDisable() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (m_ArgsBuffer != <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>                m_ArgsBuffer.Release();
</span></span><span style="display:flex;"><span>            m_ArgsBuffer = <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if</span> UNITY_EDITOR
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> OnDrawGizmos() {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//draw bounding box</span>
</span></span><span style="display:flex;"><span>            Gizmos.color = Color.red;
</span></span><span style="display:flex;"><span>            Gizmos.DrawWireCube(transform.position, dimension);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="next-steps">Next Steps<a hidden class="anchor" aria-hidden="true" href="#next-steps">#</a></h3>
<p>As you can see, we have created a GPU instancing grass system&hellip;for flat surfaces without any obstacles&hellip;, which isn&rsquo;t very useful. The good thing is that we have implemented the control map and noise map, all that&rsquo;s left is a tool to generate those maps based on the real environment.</p>
<p>In the next post, we will create an tool based on untiy&rsquo;s EditorWindow to bake the control map and noise map!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://sky-haihai.github.io/Yaotian-Huang/tags/unity/">Unity</a></li>
      <li><a href="https://sky-haihai.github.io/Yaotian-Huang/tags/shader/">Shader</a></li>
      <li><a href="https://sky-haihai.github.io/Yaotian-Huang/tags/gpu-instancing/">GPU Instancing</a></li>
      <li><a href="https://sky-haihai.github.io/Yaotian-Huang/tags/grass/">Grass</a></li>
      <li><a href="https://sky-haihai.github.io/Yaotian-Huang/tags/urp/">URP</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://sky-haihai.github.io/Yaotian-Huang/posts/webdev/notes-on-learning-mozilla-hubs-avator/">
    <span class="title">Next »</span>
    <br>
    <span>Notes on Learning Mozilla Hubs: Avator</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Create Stylized GPU Instancing Billboard Grass Without Creating Position Buffer in URP on twitter"
        href="https://twitter.com/intent/tweet/?text=Create%20Stylized%20GPU%20Instancing%20Billboard%20Grass%20Without%20Creating%20Position%20Buffer%20in%20URP&amp;url=https%3a%2f%2fsky-haihai.github.io%2fYaotian-Huang%2fposts%2fgamedev%2fcreate-stylized-gpu-instancing-billboard-grass-without-creating-position-buffer-in-urp%2f&amp;hashtags=Unity%2cShader%2cGPUInstancing%2cGrass%2cURP">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Create Stylized GPU Instancing Billboard Grass Without Creating Position Buffer in URP on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsky-haihai.github.io%2fYaotian-Huang%2fposts%2fgamedev%2fcreate-stylized-gpu-instancing-billboard-grass-without-creating-position-buffer-in-urp%2f&amp;title=Create%20Stylized%20GPU%20Instancing%20Billboard%20Grass%20Without%20Creating%20Position%20Buffer%20in%20URP&amp;summary=Create%20Stylized%20GPU%20Instancing%20Billboard%20Grass%20Without%20Creating%20Position%20Buffer%20in%20URP&amp;source=https%3a%2f%2fsky-haihai.github.io%2fYaotian-Huang%2fposts%2fgamedev%2fcreate-stylized-gpu-instancing-billboard-grass-without-creating-position-buffer-in-urp%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Create Stylized GPU Instancing Billboard Grass Without Creating Position Buffer in URP on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fsky-haihai.github.io%2fYaotian-Huang%2fposts%2fgamedev%2fcreate-stylized-gpu-instancing-billboard-grass-without-creating-position-buffer-in-urp%2f&title=Create%20Stylized%20GPU%20Instancing%20Billboard%20Grass%20Without%20Creating%20Position%20Buffer%20in%20URP">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Create Stylized GPU Instancing Billboard Grass Without Creating Position Buffer in URP on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsky-haihai.github.io%2fYaotian-Huang%2fposts%2fgamedev%2fcreate-stylized-gpu-instancing-billboard-grass-without-creating-position-buffer-in-urp%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Create Stylized GPU Instancing Billboard Grass Without Creating Position Buffer in URP on whatsapp"
        href="https://api.whatsapp.com/send?text=Create%20Stylized%20GPU%20Instancing%20Billboard%20Grass%20Without%20Creating%20Position%20Buffer%20in%20URP%20-%20https%3a%2f%2fsky-haihai.github.io%2fYaotian-Huang%2fposts%2fgamedev%2fcreate-stylized-gpu-instancing-billboard-grass-without-creating-position-buffer-in-urp%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Create Stylized GPU Instancing Billboard Grass Without Creating Position Buffer in URP on telegram"
        href="https://telegram.me/share/url?text=Create%20Stylized%20GPU%20Instancing%20Billboard%20Grass%20Without%20Creating%20Position%20Buffer%20in%20URP&amp;url=https%3a%2f%2fsky-haihai.github.io%2fYaotian-Huang%2fposts%2fgamedev%2fcreate-stylized-gpu-instancing-billboard-grass-without-creating-position-buffer-in-urp%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://sky-haihai.github.io/Yaotian-Huang/">Yaotian Huang</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
