<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Layer-based Screen-Door Transparency Effect using Unity URP 12 | Yaotian Huang</title>
<meta name="keywords" content="Screen-Door Transparency, Unity, URP, Shader, Render Feature">
<meta name="description" content="Introduction In this post, I will be discussing how I implemented a Screen-door transparency effect in Unity using URP 12. This effect is used to simulate the look of a transparent object by applying Bayer Ordered Dithering to the semi-transparent object. This effect can be used in games to give the player a better view of the character even when the character is coverd by obstacles.
How it works You can think of this effect as using a sharp pencil to poke a dense grid of holes onto a paper to reveal the objects behind the paper.">
<meta name="author" content="sky_haihai">
<link rel="canonical" href="https://sky-haihai.github.io/Yaotian-Huang/posts/gamedev/layer-based-screen-door-transparency-effect-using-unity-urp-12/">
<link crossorigin="anonymous" href="/Yaotian-Huang/assets/css/stylesheet.62aa25427797f8efd87301a5b69795dc50df2dbe79a5fba0648cc7bb8dbcd7c9.css" integrity="sha256-YqolQneX&#43;O/YcwGltpeV3FDfLb55pfugZIzHu42818k=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/Yaotian-Huang/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://sky-haihai.github.io/Yaotian-Huang/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sky-haihai.github.io/Yaotian-Huang/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sky-haihai.github.io/Yaotian-Huang/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sky-haihai.github.io/Yaotian-Huang/apple-touch-icon.png">
<link rel="mask-icon" href="https://sky-haihai.github.io/Yaotian-Huang/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Layer-based Screen-Door Transparency Effect using Unity URP 12" />
<meta property="og:description" content="Introduction In this post, I will be discussing how I implemented a Screen-door transparency effect in Unity using URP 12. This effect is used to simulate the look of a transparent object by applying Bayer Ordered Dithering to the semi-transparent object. This effect can be used in games to give the player a better view of the character even when the character is coverd by obstacles.
How it works You can think of this effect as using a sharp pencil to poke a dense grid of holes onto a paper to reveal the objects behind the paper." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sky-haihai.github.io/Yaotian-Huang/posts/gamedev/layer-based-screen-door-transparency-effect-using-unity-urp-12/" /><meta property="og:image" content="https://sky-haihai.github.io/Yaotian-Huang/posts/gamedev/layer-based-screen-door-transparency-effect-using-unity-urp-12/feature-setting.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-07T22:54:14-04:00" />
<meta property="article:modified_time" content="2023-05-07T22:54:14-04:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://sky-haihai.github.io/Yaotian-Huang/posts/gamedev/layer-based-screen-door-transparency-effect-using-unity-urp-12/feature-setting.png"/>
<meta name="twitter:title" content="Layer-based Screen-Door Transparency Effect using Unity URP 12"/>
<meta name="twitter:description" content="Introduction In this post, I will be discussing how I implemented a Screen-door transparency effect in Unity using URP 12. This effect is used to simulate the look of a transparent object by applying Bayer Ordered Dithering to the semi-transparent object. This effect can be used in games to give the player a better view of the character even when the character is coverd by obstacles.
How it works You can think of this effect as using a sharp pencil to poke a dense grid of holes onto a paper to reveal the objects behind the paper."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sky-haihai.github.io/Yaotian-Huang/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Layer-based Screen-Door Transparency Effect using Unity URP 12",
      "item": "https://sky-haihai.github.io/Yaotian-Huang/posts/gamedev/layer-based-screen-door-transparency-effect-using-unity-urp-12/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Layer-based Screen-Door Transparency Effect using Unity URP 12",
  "name": "Layer-based Screen-Door Transparency Effect using Unity URP 12",
  "description": "Introduction In this post, I will be discussing how I implemented a Screen-door transparency effect in Unity using URP 12. This effect is used to simulate the look of a transparent object by applying Bayer Ordered Dithering to the semi-transparent object. This effect can be used in games to give the player a better view of the character even when the character is coverd by obstacles.\nHow it works You can think of this effect as using a sharp pencil to poke a dense grid of holes onto a paper to reveal the objects behind the paper.",
  "keywords": [
    "Screen-Door Transparency", "Unity", "URP", "Shader", "Render Feature"
  ],
  "articleBody": "Introduction In this post, I will be discussing how I implemented a Screen-door transparency effect in Unity using URP 12. This effect is used to simulate the look of a transparent object by applying Bayer Ordered Dithering to the semi-transparent object. This effect can be used in games to give the player a better view of the character even when the character is coverd by obstacles.\nHow it works You can think of this effect as using a sharp pencil to poke a dense grid of holes onto a paper to reveal the objects behind the paper. Also you can use a Threshold value to control how transparent the object is, a.k.a, how density of the grid of holes.\nShader-wise speaking, the effect can be divided into following steps:\nPrepare a temporary texture to store the result of the effect. Render a character-layer-only color texture using a character layer filter. Render a character layer depth texture. Render a obstacle layer depth texture to be compared with the character depth to determine whether the character is covered by obstacles. Send these textures with the camera RenderTarget as an texture to the compute shader to let it draw the final result onto the temporary texture we created in step#1. (Optional) Resize the temporary texture to the size of the camera RenderTarget. Blit the temporary texture onto the camera RenderTarget. Demo Hereâ€™s a quick demo of the effect.\nAnother detailed explanation of the effect, showcasing how this effect reacts to different threshold values. From here, if you are fimiliar with the concept of render feature and render pass, and just want to see the ordered dithering part, you can skip to the #execute-method section. To see the final code, skip to here: #source-code\nEnvironment Unity 2021.3.16f1 URP 12.0.0 Implementation From Requirements The first thing to do before implementing anything for me in most development cases is to abstract requirements into a function and determine the inputs and outputs.\nIn this project, the requirements are:\nLayer-based. The user should be able to specify both the Character Layers to apply the Screen-door transparency effect on, and the layers to be used as the Obstacle Layers. Ordered Dithering algorithm. The user should be able to specify the Threshold of the dithering. Screen Space. Since the effect is layer-based, this effect should be applied in the Post-Processing Stage. Threshold. The user should be able to specify the threshold value for the Screen-door transparency effect to get the desired transparency effect. To Inputs From these requirements, we can determine that the inputs are:\nInput Type Character LayerMask LayerMask Obstacle LayerMask LayerMask Ordered Dithering Shader Compute Shader Threshold Value float Render Pass Event RenderPassEvent Put into a Setting class, we have:\n[System.Serializable] public class Settings { public ComputeShader computeShader; public LayerMask targetLayer; public LayerMask obstacleLayer; public RenderPassEvent renderPassEvent = RenderPassEvent.AfterRenderingTransparents; [Range(0, 1f)] public float ditheringThreshold = 0.5f; //For Debugging(Optional) public bool previewInSceneView = true; } Render Pass Structure Now to create a new C# class that inherits ScriptableRenderPass, including settings we just created.\nprivate class ScreenDoorRenderPass : ScriptableRenderPass { private Settings m_Settings; public ScreenDoorRenderPass(Settings settings) { m_Settings = settings; } public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) { //Configure render target and render texture } public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData) { //Construct and execute command buffer } public override void FrameCleanup(CommandBuffer cmd) { //Release temporary textures } } Variables Inside of the render pass, we need to create a few variables to store the temporary render textures and render target handles.\nprivate RenderTargetHandle m_TempCameraOpaque; //camera color private RenderTexture m_TargetOpaqueTexture; //target layer color private RenderTexture m_TargetDepthTexture; //target layer depth private RenderTexture m_ObstacleDepthTexture; //obstacle layer depth Note: Donâ€™t be scared by the type names. RenderTargetHandle, RenderTargetIdentifier, RenderTexture, etc. They all does the same thing: storing a texture.\nIn GPU, each texture is associated with a unique ID. RenderTargetHandle, RenderTargetIdentifier are just wrappers around the texture ID while RenderTexture is a wrapper around the texture itself.\nConfigure Method Now we can configure the render target and render texture in the Configure function.\npublic override void Configure(CommandBuffer cmd,RenderTextureDescriptor cameraTextureDescriptor) { var descriptor = cameraTextureDescriptor; descriptor.enableRandomWrite = true; cmd.GetTemporaryRT(m_TempCameraOpaque.id, descriptor); m_TargetOpaqueTexture = RenderTexture.GetTemporary(cameraTextureDescriptor.width, cameraTextureDescriptor.height, 0, RenderTextureFormat.ARGB32); m_TargetDepthTexture = RenderTexture.GetTemporary(cameraTextureDescriptor.width, cameraTextureDescriptor.height, 16, RenderTextureFormat.Depth); m_ObstacleDepthTexture = RenderTexture.GetTemporary(cameraTextureDescriptor.width, cameraTextureDescriptor.height, 16, RenderTextureFormat.Depth); } Frame Cleanup Method Finish the FrameCleanup function while we still remember.\npublic override void FrameCleanup(CommandBuffer cmd) { cmd.ReleaseTemporaryRT(m_TempCameraOpaque.id); RenderTexture.ReleaseTemporary(m_TargetOpaqueTexture); RenderTexture.ReleaseTemporary(m_TargetDepthTexture); RenderTexture.ReleaseTemporary(m_ObstacleDepthTexture); } Execute Method Finally, we can start to write the Execute function where the actual rendering logic locates. Since the code is relatively long, I will explain it in chunks.\n// Fetch a command buffer from the command pool, remember to release it at the end of the function CommandBuffer cmd = CommandBufferPool.Get(name: \"Screen Door Transparency\"); // Clear the command buffer in case there are some commands left cmd.Clear(); Command buffers are used to store GPU commands. We can think of it as a list of GPU commands.\nAfter fetching the command buffer, prepare the drawing settings for drawing opaque(colored) texture for Character layer(the layer thatâ€™s needed to be revealed from obstacles).\n// Prepare the drawwing setting for opaque texture (for character layer) var drawOpaqueSettings = CreateDrawingSettings(new ShaderTagId(\"UniversalForward\"), ref renderingData, SortingCriteria.BackToFront); // Prepare the drawing setting for depth-only mode var drawDepthSettings = CreateDrawingSettings(new ShaderTagId(\"DepthOnly\"), ref renderingData, renderingData.cameraData.defaultOpaqueSortFlags); // Prepare the filtering setting for character layer var targetFilter = new FilteringSettings(RenderQueueRange.all, m_Settings.targetLayer.value); // Prepare the filtering setting for obstacle layer var obstacleFilter = new FilteringSettings(RenderQueueRange.all, m_Settings.obstacleLayer.value); Now render all the textures using the settings we just created.\n//draw target opaque cmd.SetRenderTarget(m_TargetOpaqueTexture); cmd.ClearRenderTarget(true, true, Color.clear); context.ExecuteCommandBuffer(cmd); cmd.Clear(); context.DrawRenderers(renderingData.cullResults, ref drawOpaqueSettings, ref targetFilter); //draw target depth cmd.SetRenderTarget(m_TargetDepthTexture); cmd.ClearRenderTarget(true, false, Color.clear); context.ExecuteCommandBuffer(cmd); cmd.Clear(); context.DrawRenderers(renderingData.cullResults, ref drawDepthSettings, ref targetFilter); //draw obstacle depth cmd.SetRenderTarget(m_ObstacleDepthTexture); cmd.ClearRenderTarget(true, false, Color.clear); context.ExecuteCommandBuffer(cmd); cmd.Clear(); context.DrawRenderers(renderingData.cullResults, ref drawDepthSettings, ref obstacleFilter); //reset render target var cam = renderingData.cameraData.renderer; cmd.SetRenderTarget(cam.cameraColorTarget, cam.cameraDepthTarget); //cache camera color which will be used later in the compute shader as a source texture cmd.Blit(cam.cameraColorTarget, m_TempCameraOpaque.Identifier()); Note\nThe commands inside CommandBuffer wonâ€™t be executed before context.ExecuteCommandBuffer(cmd). Therefore context.ExecuteCommandBuffer(cmd) is needed before every context.DrawRenderers(...) to make sure the commands are executed before we draw any textures.\nAt this point, we have rendered all the textures we need. Now we can pass them to the compute shader:\n//get kernel var shader = m_Settings.computeShader; var mainKernel = shader.FindKernel(\"BayerOrderedDithering\"); //set textures and parameters cmd.SetComputeTextureParam(shader, mainKernel, \"_InputTexture\", cam.cameraColorTarget); cmd.SetComputeTextureParam(shader, mainKernel, \"_TargetOpaqueTexture\", m_TargetOpaqueTexture); cmd.SetComputeTextureParam(shader, mainKernel, \"_TargetDepthTexture\", m_TargetDepthTexture); cmd.SetComputeTextureParam(shader, mainKernel, \"_ObstacleDepthTexture\", m_ObstacleDepthTexture); cmd.SetComputeTextureParam(shader, mainKernel, \"_OutputTexture\", m_TempCameraOpaque.Identifier()); cmd.SetComputeFloatParam(shader, \"_DitherThreshold\", m_Settings.ditheringThreshold); //define thread group size int threadGroupX = Mathf.CeilToInt(renderingData.cameraData.camera.scaledPixelWidth / 8.0f); int threadGroupY = Mathf.CeilToInt(renderingData.cameraData.camera.scaledPixelHeight / 8.0f); //dispatch compute shader cmd.DispatchCompute(shader, mainKernel, threadGroupX, threadGroupY, 1); //draw the result back to screen cmd.Blit(m_TempCameraOpaque.id, cam.cameraColorTarget); The denominator when calculating the threadGroup sizes must match the numthreads attribute in the compute shader to get a full screen processing, in my compute shader it is set to [numthreads(8,8, 1)], there fore we divide the screen width and height by 8.\nAt this point, we have defined all the commands for the ComputeBuffer. Now we just need to execute it.\n//submit commands to the GPU context.ExecuteCommandBuffer(cmd); //release command buffer from RAM CommandBufferPool.Release(cmd); //might be unnecessary, unity will do this for us in the end of execute method, but just in case context.Submit(); Now we have finished our ScreenDoorRenderPass.\nRender Feature To use the render pass we just created, create a new C# class that inherits ScriptableRendererFeature.\nusing UnityEngine; using UnityEngine.Rendering; using UnityEngine.Rendering.Universal; public class ScreenDoorRenderFeature : ScriptableRendererFeature { [SerializeField] public Settings settings = new Settings(); ScreenDoorRenderPass m_RenderPass; public override void Create() { m_RenderPass = new ScreenDoorRenderPass(settings) { renderPassEvent = settings.renderPassEvent }; } public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData) { if (settings.computeShader != null \u0026\u0026 settings.targetLayer != 0 \u0026\u0026 settings.obstacleLayer != 0) { renderer.EnqueuePass(m_RenderPass); } } } Whatâ€™s going on here is relatively simple. We create a new ScreenDoorRenderPass and set its renderPassEvent to the one we defined in the inspector. Then we add the render pass to the rendererâ€™s queue.\nAnd thatâ€™s it! Now we can use the render feature in our renderer settings.\nSource Code Source Code: Screen Door Transparency\nRenderer Asset Note The basic setup for an URP project is not part of the scope for this article. If you donâ€™t know how to do that, please refer to this manual page: InstallURPIntoAProject.\nMake sure to enable opaque texture and depth texture in the URP asset.\nFind your URP renderer asset and add the render feature we just created.\nDrag the compute shader we create eariler in, and set the target layer to the ones you want to reveal from obstacles and as the name suggested , set all the environment layers as obstacle layer.\nFor example, in the video demo, the layer for the green boxes are set to be osbatcle layer, and the layer for the orange balls are set to be target layer.\nFuture Improvements Add a dropdown menu to the render feature to allow the user to select different sizes of Bayer Matrixes. Support Transparent objects. Optimize the performance of the render feature by reducing the size of the temporary textures. The current project Iâ€™m working on doesnâ€™t require a object-based Screen Door Effect. But if you need it, you can just add a oredered dithering pass to the shader. References Ordered Dithering - Computerphile\nhttps://youtu.be/IviNO7iICTM\nOrdered dithering - Wikipedia\nhttps://en.wikipedia.org/wiki/Ordered_dithering\n",
  "wordCount" : "1543",
  "inLanguage": "en",
  "datePublished": "2023-05-07T22:54:14-04:00",
  "dateModified": "2023-05-07T22:54:14-04:00",
  "author":{
    "@type": "Person",
    "name": "sky_haihai"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sky-haihai.github.io/Yaotian-Huang/posts/gamedev/layer-based-screen-door-transparency-effect-using-unity-urp-12/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Yaotian Huang",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sky-haihai.github.io/Yaotian-Huang/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sky-haihai.github.io/Yaotian-Huang/" accesskey="h" title="Yaotian Huang (Alt + H)">Yaotian Huang</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sky-haihai.github.io/Yaotian-Huang/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://sky-haihai.github.io/Yaotian-Huang/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://sky-haihai.github.io/Yaotian-Huang/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://sky-haihai.github.io/Yaotian-Huang/">Home</a>&nbsp;Â»&nbsp;<a href="https://sky-haihai.github.io/Yaotian-Huang/posts/">Posts</a></div>
    <h1 class="post-title">
      Layer-based Screen-Door Transparency Effect using Unity URP 12
    </h1>
    <div class="post-meta"><span title='2023-05-07 22:54:14 -0400 EDT'>May 7, 2023</span>&nbsp;Â·&nbsp;8 min&nbsp;Â·&nbsp;sky_haihai

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#how-it-works" aria-label="How it works">How it works</a></li>
                <li>
                    <a href="#demo" aria-label="Demo">Demo</a></li>
                <li>
                    <a href="#environment" aria-label="Environment">Environment</a></li>
                <li>
                    <a href="#implementation" aria-label="Implementation">Implementation</a><ul>
                        
                <li>
                    <a href="#from-requirements" aria-label="From Requirements">From Requirements</a></li>
                <li>
                    <a href="#to-inputs" aria-label="To Inputs">To Inputs</a></li>
                <li>
                    <a href="#render-pass" aria-label="Render Pass">Render Pass</a><ul>
                        
                <li>
                    <a href="#structure" aria-label="Structure">Structure</a></li>
                <li>
                    <a href="#variables" aria-label="Variables">Variables</a></li>
                <li>
                    <a href="#configure-method" aria-label="Configure Method">Configure Method</a></li>
                <li>
                    <a href="#frame-cleanup-method" aria-label="Frame Cleanup Method">Frame Cleanup Method</a></li>
                <li>
                    <a href="#execute-method" aria-label="Execute Method">Execute Method</a></li></ul>
                </li>
                <li>
                    <a href="#render-feature" aria-label="Render Feature">Render Feature</a></li>
                <li>
                    <a href="#source-code" aria-label="Source Code">Source Code</a></li>
                <li>
                    <a href="#renderer-asset" aria-label="Renderer Asset">Renderer Asset</a></li></ul>
                </li>
                <li>
                    <a href="#future-improvements" aria-label="Future Improvements">Future Improvements</a></li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>In this post, I will be discussing how I implemented a <strong>Screen-door transparency</strong> effect in Unity using <strong>URP 12</strong>. This effect is used to simulate the look of a transparent object by applying <strong>Bayer Ordered Dithering</strong> to the semi-transparent object. This effect can be used in games to give the player a better view of the character even when the character is coverd by obstacles.</p>
<h2 id="how-it-works">How it works<a hidden class="anchor" aria-hidden="true" href="#how-it-works">#</a></h2>
<p>You can think of this effect as using a sharp pencil to poke a dense grid of holes onto a paper to reveal the objects behind the paper. Also you can use a Threshold value to control how transparent the object is, a.k.a, how density of the grid of holes.</p>
<p>Shader-wise speaking, the effect can be divided into following steps:</p>
<ol>
<li>Prepare a temporary texture to store the result of the effect.</li>
<li>Render a character-layer-only color texture using a character layer filter.</li>
<li>Render a character layer depth texture.</li>
<li>Render a obstacle layer depth texture to be compared with the character depth to determine whether the character is covered by obstacles.</li>
<li>Send these textures with the camera <strong>RenderTarget</strong> as an texture to the compute shader to let it draw the final result onto the temporary texture we created in step#1.</li>
<li><em><strong>(Optional)</strong></em> Resize the temporary texture to the size of the camera <strong>RenderTarget</strong>.</li>
<li>Blit the temporary texture onto the camera <strong>RenderTarget</strong>.</li>
</ol>
<h2 id="demo">Demo<a hidden class="anchor" aria-hidden="true" href="#demo">#</a></h2>
<p>Here&rsquo;s a quick demo of the effect.</p>
<p>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/D8kw0DIIDWQ" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>
<br>
Another detailed explanation of the effect, showcasing how this effect reacts to different threshold values.

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/ebjjGDwZ6kw" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>
</p>
<p>From here, if you are fimiliar with the concept of render feature and render pass, and just want to see the ordered dithering part, you can skip to the <a href="#execute-method">#execute-method</a> section. To see the final code, skip to here: <a href="#source-code">#source-code</a></p>
<h2 id="environment">Environment<a hidden class="anchor" aria-hidden="true" href="#environment">#</a></h2>
<ul>
<li>Unity <code>2021.3.16f1</code></li>
<li>URP <code>12.0.0</code></li>
</ul>
<h2 id="implementation">Implementation<a hidden class="anchor" aria-hidden="true" href="#implementation">#</a></h2>
<h3 id="from-requirements">From Requirements<a hidden class="anchor" aria-hidden="true" href="#from-requirements">#</a></h3>
<p>The first thing to do before implementing anything for me in most development cases is to abstract requirements into a function and determine the inputs and outputs.</p>
<p>In this project, the requirements are:</p>
<ol>
<li>Layer-based. The user should be able to specify both the <strong>Character Layers</strong> to apply the Screen-door transparency effect on, and the layers to be used as the <strong>Obstacle Layers</strong>.</li>
<li><strong>Ordered Dithering</strong> algorithm. The user should be able to specify the <strong>Threshold</strong> of the dithering.</li>
<li><strong>Screen Space</strong>. Since the effect is layer-based, this effect should be applied in the <strong>Post-Processing Stage</strong>.</li>
<li>Threshold. The user should be able to specify the threshold value for the <strong>Screen-door transparency</strong> effect to get the desired transparency effect.</li>
</ol>
<h3 id="to-inputs">To Inputs<a hidden class="anchor" aria-hidden="true" href="#to-inputs">#</a></h3>
<p>From these requirements, we can determine that the inputs are:</p>
<table>
<thead>
<tr>
<th>Input</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>Character LayerMask</td>
<td>LayerMask</td>
</tr>
<tr>
<td>Obstacle LayerMask</td>
<td>LayerMask</td>
</tr>
<tr>
<td>Ordered Dithering Shader</td>
<td>Compute Shader</td>
</tr>
<tr>
<td>Threshold Value</td>
<td>float</td>
</tr>
<tr>
<td>Render Pass Event</td>
<td>RenderPassEvent</td>
</tr>
</tbody>
</table>
<p>Put into a <code>Setting</code> class, we have:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#a6e22e">[System.Serializable]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Settings</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ComputeShader computeShader;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> LayerMask targetLayer;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> LayerMask obstacleLayer;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> RenderPassEvent renderPassEvent = RenderPassEvent.AfterRenderingTransparents;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [Range(0, 1f)]</span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">float</span> ditheringThreshold = <span style="color:#ae81ff">0.5f</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//For Debugging(Optional)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> previewInSceneView = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="render-pass">Render Pass<a hidden class="anchor" aria-hidden="true" href="#render-pass">#</a></h3>
<h4 id="structure">Structure<a hidden class="anchor" aria-hidden="true" href="#structure">#</a></h4>
<p>Now to create a new C# class that inherits <code>ScriptableRenderPass</code>, including settings we just created.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ScreenDoorRenderPass</span> : ScriptableRenderPass {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Settings m_Settings;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ScreenDoorRenderPass(Settings settings) {
</span></span><span style="display:flex;"><span>        m_Settings = settings;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//Configure render target and render texture</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Execute(ScriptableRenderContext context, <span style="color:#66d9ef">ref</span> RenderingData renderingData) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//Construct and execute command buffer</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> FrameCleanup(CommandBuffer cmd) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//Release temporary textures</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="variables">Variables<a hidden class="anchor" aria-hidden="true" href="#variables">#</a></h4>
<p>Inside of the render pass, we need to create a few variables to store the temporary render textures and render target handles.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> RenderTargetHandle m_TempCameraOpaque; <span style="color:#75715e">//camera color</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> RenderTexture m_TargetOpaqueTexture; <span style="color:#75715e">//target layer color</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> RenderTexture m_TargetDepthTexture; <span style="color:#75715e">//target layer depth</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> RenderTexture m_ObstacleDepthTexture; <span style="color:#75715e">//obstacle layer depth</span>
</span></span></code></pre></div><blockquote>
<p><strong>Note</strong>:
Don&rsquo;t be scared by the type names. <code>RenderTargetHandle</code>, <code>RenderTargetIdentifier</code>, <code>RenderTexture</code>, etc. They all does the same thing: storing a texture.<br>
In GPU, each texture is associated with a unique ID. <code>RenderTargetHandle</code>, <code>RenderTargetIdentifier</code> are just wrappers around the texture ID while <code>RenderTexture</code> is a wrapper around the texture itself.</p>
</blockquote>
<h4 id="configure-method">Configure Method<a hidden class="anchor" aria-hidden="true" href="#configure-method">#</a></h4>
<p>Now we can configure the render target and render texture in the <code>Configure</code> function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Configure(CommandBuffer cmd,RenderTextureDescriptor cameraTextureDescriptor) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> descriptor = cameraTextureDescriptor;
</span></span><span style="display:flex;"><span>    descriptor.enableRandomWrite = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    cmd.GetTemporaryRT(m_TempCameraOpaque.id, descriptor);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    m_TargetOpaqueTexture = RenderTexture.GetTemporary(cameraTextureDescriptor.width, cameraTextureDescriptor.height, <span style="color:#ae81ff">0</span>, RenderTextureFormat.ARGB32);
</span></span><span style="display:flex;"><span>    m_TargetDepthTexture = RenderTexture.GetTemporary(cameraTextureDescriptor.width, cameraTextureDescriptor.height, <span style="color:#ae81ff">16</span>, RenderTextureFormat.Depth);
</span></span><span style="display:flex;"><span>    m_ObstacleDepthTexture = RenderTexture.GetTemporary(cameraTextureDescriptor.width, cameraTextureDescriptor.height, <span style="color:#ae81ff">16</span>, RenderTextureFormat.Depth);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="frame-cleanup-method">Frame Cleanup Method<a hidden class="anchor" aria-hidden="true" href="#frame-cleanup-method">#</a></h4>
<p>Finish the <code>FrameCleanup</code> function while we still remember.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> FrameCleanup(CommandBuffer cmd) {
</span></span><span style="display:flex;"><span>    cmd.ReleaseTemporaryRT(m_TempCameraOpaque.id);
</span></span><span style="display:flex;"><span>    RenderTexture.ReleaseTemporary(m_TargetOpaqueTexture);
</span></span><span style="display:flex;"><span>    RenderTexture.ReleaseTemporary(m_TargetDepthTexture);
</span></span><span style="display:flex;"><span>    RenderTexture.ReleaseTemporary(m_ObstacleDepthTexture);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="execute-method">Execute Method<a hidden class="anchor" aria-hidden="true" href="#execute-method">#</a></h4>
<p>Finally, we can start to write the <code>Execute</code> function where the actual rendering logic locates. Since the code is relatively long, I will explain it in chunks.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#75715e">// Fetch a command buffer from the command pool, remember to release it at the end of the function</span>
</span></span><span style="display:flex;"><span>CommandBuffer cmd = CommandBufferPool.Get(name: <span style="color:#e6db74">&#34;Screen Door Transparency&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Clear the command buffer in case there are some commands left</span>
</span></span><span style="display:flex;"><span>cmd.Clear();
</span></span></code></pre></div><p>Command buffers are used to store GPU commands. We can think of it as a list of GPU commands.</p>
<p><br>
After fetching the command buffer, prepare the drawing settings for drawing opaque(colored) texture for Character layer(the layer that&rsquo;s needed to be revealed from obstacles).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#75715e">// Prepare the drawwing setting for opaque texture (for character layer)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> drawOpaqueSettings = CreateDrawingSettings(<span style="color:#66d9ef">new</span> ShaderTagId(<span style="color:#e6db74">&#34;UniversalForward&#34;</span>), <span style="color:#66d9ef">ref</span> renderingData, SortingCriteria.BackToFront);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Prepare the drawing setting for depth-only mode</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> drawDepthSettings = CreateDrawingSettings(<span style="color:#66d9ef">new</span> ShaderTagId(<span style="color:#e6db74">&#34;DepthOnly&#34;</span>), <span style="color:#66d9ef">ref</span> renderingData, renderingData.cameraData.defaultOpaqueSortFlags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Prepare the filtering setting for character layer</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> targetFilter = <span style="color:#66d9ef">new</span> FilteringSettings(RenderQueueRange.all, m_Settings.targetLayer.<span style="color:#66d9ef">value</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Prepare the filtering setting for obstacle layer</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> obstacleFilter = <span style="color:#66d9ef">new</span> FilteringSettings(RenderQueueRange.all, m_Settings.obstacleLayer.<span style="color:#66d9ef">value</span>);
</span></span></code></pre></div><p><br>
Now render all the textures using the settings we just created.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#75715e">//draw target opaque</span>
</span></span><span style="display:flex;"><span>cmd.SetRenderTarget(m_TargetOpaqueTexture);
</span></span><span style="display:flex;"><span>cmd.ClearRenderTarget(<span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>, Color.clear);
</span></span><span style="display:flex;"><span>context.ExecuteCommandBuffer(cmd);
</span></span><span style="display:flex;"><span>cmd.Clear();
</span></span><span style="display:flex;"><span>context.DrawRenderers(renderingData.cullResults, <span style="color:#66d9ef">ref</span> drawOpaqueSettings, <span style="color:#66d9ef">ref</span> targetFilter);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//draw target depth</span>
</span></span><span style="display:flex;"><span>cmd.SetRenderTarget(m_TargetDepthTexture);
</span></span><span style="display:flex;"><span>cmd.ClearRenderTarget(<span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>, Color.clear);
</span></span><span style="display:flex;"><span>context.ExecuteCommandBuffer(cmd);
</span></span><span style="display:flex;"><span>cmd.Clear();
</span></span><span style="display:flex;"><span>context.DrawRenderers(renderingData.cullResults, <span style="color:#66d9ef">ref</span> drawDepthSettings, <span style="color:#66d9ef">ref</span> targetFilter);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//draw obstacle depth</span>
</span></span><span style="display:flex;"><span>cmd.SetRenderTarget(m_ObstacleDepthTexture);
</span></span><span style="display:flex;"><span>cmd.ClearRenderTarget(<span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>, Color.clear);
</span></span><span style="display:flex;"><span>context.ExecuteCommandBuffer(cmd);
</span></span><span style="display:flex;"><span>cmd.Clear();
</span></span><span style="display:flex;"><span>context.DrawRenderers(renderingData.cullResults, <span style="color:#66d9ef">ref</span> drawDepthSettings, <span style="color:#66d9ef">ref</span> obstacleFilter);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//reset render target</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> cam = renderingData.cameraData.renderer;
</span></span><span style="display:flex;"><span>cmd.SetRenderTarget(cam.cameraColorTarget, cam.cameraDepthTarget);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//cache camera color which will be used later in the compute shader as a source texture</span>
</span></span><span style="display:flex;"><span>cmd.Blit(cam.cameraColorTarget, m_TempCameraOpaque.Identifier());
</span></span></code></pre></div><blockquote>
<p><strong>Note</strong><br>
The commands inside <code>CommandBuffer</code> won&rsquo;t be executed before <code>context.ExecuteCommandBuffer(cmd)</code>. Therefore  <code>context.ExecuteCommandBuffer(cmd)</code> is needed before every <code>context.DrawRenderers(...)</code> to make sure the commands are executed before we draw any textures.</p>
</blockquote>
<p>At this point, we have rendered all the textures we need. Now we can pass them to the compute shader:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#75715e">//get kernel</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> shader = m_Settings.computeShader;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> mainKernel = shader.FindKernel(<span style="color:#e6db74">&#34;BayerOrderedDithering&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//set textures and parameters</span>
</span></span><span style="display:flex;"><span>cmd.SetComputeTextureParam(shader, mainKernel, <span style="color:#e6db74">&#34;_InputTexture&#34;</span>, cam.cameraColorTarget);
</span></span><span style="display:flex;"><span>cmd.SetComputeTextureParam(shader, mainKernel, <span style="color:#e6db74">&#34;_TargetOpaqueTexture&#34;</span>, m_TargetOpaqueTexture);
</span></span><span style="display:flex;"><span>cmd.SetComputeTextureParam(shader, mainKernel, <span style="color:#e6db74">&#34;_TargetDepthTexture&#34;</span>, m_TargetDepthTexture);
</span></span><span style="display:flex;"><span>cmd.SetComputeTextureParam(shader, mainKernel, <span style="color:#e6db74">&#34;_ObstacleDepthTexture&#34;</span>, m_ObstacleDepthTexture);
</span></span><span style="display:flex;"><span>cmd.SetComputeTextureParam(shader, mainKernel, <span style="color:#e6db74">&#34;_OutputTexture&#34;</span>, m_TempCameraOpaque.Identifier());
</span></span><span style="display:flex;"><span>cmd.SetComputeFloatParam(shader, <span style="color:#e6db74">&#34;_DitherThreshold&#34;</span>, m_Settings.ditheringThreshold);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//define thread group size</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> threadGroupX = Mathf.CeilToInt(renderingData.cameraData.camera.scaledPixelWidth / <span style="color:#ae81ff">8.0f</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> threadGroupY = Mathf.CeilToInt(renderingData.cameraData.camera.scaledPixelHeight / <span style="color:#ae81ff">8.0f</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//dispatch compute shader</span>
</span></span><span style="display:flex;"><span>cmd.DispatchCompute(shader, mainKernel, threadGroupX, threadGroupY, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//draw the result back to screen</span>
</span></span><span style="display:flex;"><span>cmd.Blit(m_TempCameraOpaque.id, cam.cameraColorTarget);
</span></span></code></pre></div><p>The denominator when calculating the threadGroup sizes must match the numthreads attribute in the compute shader to get a full screen processing, in my compute shader it is set to [numthreads(8,8, 1)], there fore we divide the screen width and height by 8.</p>
<p>At this point, we have defined all the commands for the <code>ComputeBuffer</code>. Now we just need to execute it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#75715e">//submit commands to the GPU</span>
</span></span><span style="display:flex;"><span>context.ExecuteCommandBuffer(cmd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//release command buffer from RAM</span>
</span></span><span style="display:flex;"><span>CommandBufferPool.Release(cmd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//might be unnecessary, unity will do this for us in the end of execute method, but just in case</span>
</span></span><span style="display:flex;"><span>context.Submit();
</span></span></code></pre></div><p>Now we have finished our <code>ScreenDoorRenderPass</code>.</p>
<h3 id="render-feature">Render Feature<a hidden class="anchor" aria-hidden="true" href="#render-feature">#</a></h3>
<p>To use the render pass we just created, create a new C# class that inherits <code>ScriptableRendererFeature</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> UnityEngine;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> UnityEngine.Rendering;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> UnityEngine.Rendering.Universal;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ScreenDoorRenderFeature</span> : ScriptableRendererFeature {
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [SerializeField]</span> <span style="color:#66d9ef">public</span> Settings settings = <span style="color:#66d9ef">new</span> Settings();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ScreenDoorRenderPass m_RenderPass;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Create() {
</span></span><span style="display:flex;"><span>        m_RenderPass = <span style="color:#66d9ef">new</span> ScreenDoorRenderPass(settings) {
</span></span><span style="display:flex;"><span>            renderPassEvent = settings.renderPassEvent
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> AddRenderPasses(ScriptableRenderer renderer, <span style="color:#66d9ef">ref</span> RenderingData renderingData) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (settings.computeShader != <span style="color:#66d9ef">null</span> &amp;&amp; settings.targetLayer != <span style="color:#ae81ff">0</span> &amp;&amp; settings.obstacleLayer != <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            renderer.EnqueuePass(m_RenderPass);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What&rsquo;s going on here is relatively simple. We create a new <code>ScreenDoorRenderPass</code> and set its <code>renderPassEvent</code> to the one we defined in the inspector. Then we add the render pass to the renderer&rsquo;s queue.</p>
<p>And that&rsquo;s it! Now we can use the render feature in our renderer settings.</p>
<h3 id="source-code">Source Code<a hidden class="anchor" aria-hidden="true" href="#source-code">#</a></h3>
<p>Source Code: <a href="https://github.com/sky-haihai/ScreenDoorSourceCode.git">Screen Door Transparency</a></p>
<h3 id="renderer-asset">Renderer Asset<a hidden class="anchor" aria-hidden="true" href="#renderer-asset">#</a></h3>
<blockquote>
<p><strong>Note</strong>
The basic setup for an URP project is not part of the scope for this article. If you don&rsquo;t know how to do that, please refer to this manual page: <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@7.1/manual/InstallURPIntoAProject.html">InstallURPIntoAProject</a>.</p>
</blockquote>
<p>Make sure to enable opaque texture and depth texture in the URP asset.</p>
<figure>
    <img loading="lazy" src="asset-setting.png"/> 
</figure>

<p><br>
Find your URP renderer asset and add the render feature we just created.</p>
<p><figure>
    <img loading="lazy" src="feature-setting.png"/> 
</figure>

Drag the compute shader we create eariler in, and set the target layer to the ones you want to reveal from obstacles and as the name suggested , set all the environment layers as obstacle layer.</p>
<p>For example, in the video <a href="#demo">demo</a>, the layer for the green boxes are set to be osbatcle layer, and the layer for the orange balls are set to be target layer.</p>
<h2 id="future-improvements">Future Improvements<a hidden class="anchor" aria-hidden="true" href="#future-improvements">#</a></h2>
<ol>
<li>Add a dropdown menu to the render feature to allow the user to select different <strong>sizes</strong> of Bayer Matrixes.</li>
<li>Support Transparent objects.</li>
<li>Optimize the <strong>performance</strong> of the render feature by reducing the size of the temporary textures.</li>
<li>The current project I&rsquo;m working on doesn&rsquo;t require a <strong>object-based</strong> Screen Door Effect. But if you need it, you can just add a oredered dithering pass to the shader.</li>
</ol>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<p>Ordered Dithering - Computerphile<br>
<a href="https://youtu.be/IviNO7iICTM">https://youtu.be/IviNO7iICTM</a></p>
<p>Ordered dithering - Wikipedia<br>
<a href="https://en.wikipedia.org/wiki/Ordered_dithering">https://en.wikipedia.org/wiki/Ordered_dithering</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://sky-haihai.github.io/Yaotian-Huang/tags/screen-door-transparency/">Screen-Door Transparency</a></li>
      <li><a href="https://sky-haihai.github.io/Yaotian-Huang/tags/unity/">Unity</a></li>
      <li><a href="https://sky-haihai.github.io/Yaotian-Huang/tags/urp/">URP</a></li>
      <li><a href="https://sky-haihai.github.io/Yaotian-Huang/tags/shader/">Shader</a></li>
      <li><a href="https://sky-haihai.github.io/Yaotian-Huang/tags/render-feature/">Render Feature</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://sky-haihai.github.io/Yaotian-Huang/posts/gamedev/recreating-the-rain-drop-effect-in-the-legend-of-zelda-totk/">
    <span class="title">Â« Prev</span>
    <br>
    <span>Recreating the Rain Drop Effect in The Legend of Zelda: TOTK</span>
  </a>
  <a class="next" href="https://sky-haihai.github.io/Yaotian-Huang/posts/uni/creating-a-diet-dashboard-based-on-angular/">
    <span class="title">Next Â»</span>
    <br>
    <span>Creating a Diet Dashboard Based on Angular</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Layer-based Screen-Door Transparency Effect using Unity URP 12 on twitter"
        href="https://twitter.com/intent/tweet/?text=Layer-based%20Screen-Door%20Transparency%20Effect%20using%20Unity%20URP%2012&amp;url=https%3a%2f%2fsky-haihai.github.io%2fYaotian-Huang%2fposts%2fgamedev%2flayer-based-screen-door-transparency-effect-using-unity-urp-12%2f&amp;hashtags=Screen-DoorTransparency%2cUnity%2cURP%2cShader%2cRenderFeature">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Layer-based Screen-Door Transparency Effect using Unity URP 12 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsky-haihai.github.io%2fYaotian-Huang%2fposts%2fgamedev%2flayer-based-screen-door-transparency-effect-using-unity-urp-12%2f&amp;title=Layer-based%20Screen-Door%20Transparency%20Effect%20using%20Unity%20URP%2012&amp;summary=Layer-based%20Screen-Door%20Transparency%20Effect%20using%20Unity%20URP%2012&amp;source=https%3a%2f%2fsky-haihai.github.io%2fYaotian-Huang%2fposts%2fgamedev%2flayer-based-screen-door-transparency-effect-using-unity-urp-12%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Layer-based Screen-Door Transparency Effect using Unity URP 12 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fsky-haihai.github.io%2fYaotian-Huang%2fposts%2fgamedev%2flayer-based-screen-door-transparency-effect-using-unity-urp-12%2f&title=Layer-based%20Screen-Door%20Transparency%20Effect%20using%20Unity%20URP%2012">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Layer-based Screen-Door Transparency Effect using Unity URP 12 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsky-haihai.github.io%2fYaotian-Huang%2fposts%2fgamedev%2flayer-based-screen-door-transparency-effect-using-unity-urp-12%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Layer-based Screen-Door Transparency Effect using Unity URP 12 on whatsapp"
        href="https://api.whatsapp.com/send?text=Layer-based%20Screen-Door%20Transparency%20Effect%20using%20Unity%20URP%2012%20-%20https%3a%2f%2fsky-haihai.github.io%2fYaotian-Huang%2fposts%2fgamedev%2flayer-based-screen-door-transparency-effect-using-unity-urp-12%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Layer-based Screen-Door Transparency Effect using Unity URP 12 on telegram"
        href="https://telegram.me/share/url?text=Layer-based%20Screen-Door%20Transparency%20Effect%20using%20Unity%20URP%2012&amp;url=https%3a%2f%2fsky-haihai.github.io%2fYaotian-Huang%2fposts%2fgamedev%2flayer-based-screen-door-transparency-effect-using-unity-urp-12%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://sky-haihai.github.io/Yaotian-Huang/">Yaotian Huang</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
